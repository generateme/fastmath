(ns vector-matrix
  (:require [fastmath.vector :as v]
            [fastmath.matrix :as mat]
            [fastmath.dev.codox :as codox]
            [fastmath.dev.clay :as utls]
            [fastmath.dev.plotly :as plt]
            [fastmath.core :as m]
            [scicloj.kindly.v4.kind :as kind]
            [fastmath.dev.ggplot :as gg]
            [fastmath.stats :as stats])
  (:import [fastmath.vector Vec2 Vec3 Vec4]
           [fastmath.matrix Mat2x2 Mat3x3 Mat4x4]))

;; # Vectors and matrices {.unnumbered}

;; ## Vectors
;;
;; The `fastmath.vector` namespace provides a comprehensive set of utilities for working with N-dimensional mathematical vectors in Clojure. It supports various vector representations, including custom fixed-size types (`Vec2`, `Vec3`, `Vec4`), Clojure persistent vectors and sequences, Java double arrays, and Apache Commons Math `ArrayRealVector`, all unified under the `fastmath.protocols/VectorProto`.
;;

;; ### Vector Types
;;
;; `fastmath.vector` supports several underlying representations for vectors, providing flexibility and performance trade-offs. The `VectorProto` ensures that most operations work consistently across these types.

;; ::: {.callout-tip title="Supported Types"}
;; * A number (1D vector)
;; * `Vec2` (2D vector, custom type)
;; * `Vec3` (3D vector, custom type)
;; * `Vec4` (4D vector, custom type)
;; * `ArrayVec` (N-dimensional, wrapper around double array, deprecated)
;; * `double[]` (Java double array, N-dimensional)
;; * Clojure `IPersistentVector` (`[]`, N-dimensional)
;; * Clojure `ISeq` (any sequence, N-dimensional)
;; * Apache Commons Math `ArrayRealVector` (N-dimensional)
;; :::

;; ::: {.callout-warning}
;; The `ArrayVec` type should be considered as deprecated. This is just a `double-array` wrapper. `double-array` itself is instrumented in `VectorProto` functions and can be used directly.
;; :::

;; Let's define fixed size vectors to use in examples:

(def V2 (Vec2. -1 2.5))
(def V3 (Vec3. -1 2.5 -3.25))
(def V4 (Vec4. -1 0.0 -3.25 4))

(utls/examples-note V2 V3 V4)

;; ### Creation and Conversion
;;
;; ::: {.callout-tip title="Defined functions"}
;; * `vec2`, `vec3`, `vec4`
;; * `array-vec`
;; * `make-vector`
;; * `generate-vec2`, `generate-vec3`, `generate-vec4`
;; * `array->vec2`, `array->vec3`, `array->vec4`
;; * `seq->vec2`, `seq->vec3`, `seq->vec4`
;; * `vec->array`, `vec->seq`, `vec->RealVector`, `real-vector`, `vec->Vec`
;; * `as-vec`
;; :::

;; #### Creation

;; *   **Fixed-size constructors**: `vec2`, `vec3`, and `vec4` create vectors with 2, 3, and 4 dimensions, respectively. They can be called with no arguments for a zero vector, or with explicit components.
;; *   **Arbitrary-size constructor**: `array-vec` takes a sequence and creates an `ArrayVec` wrapping a `double` array.
;; *   **Generic constructor**: `make-vector` takes a dimension and optionally a sequence of values. It automatically selects the appropriate fixed-size type (`Vec2`, `Vec3`, `Vec4`) for dimensions 2, 3, or 4, or creates an `ArrayVec` for other positive dimensions.
;; *   **Generator functions**: `generate-vec2`, `generate-vec3`, and `generate-vec4` create vectors whose components are generated by one or more provided functions.
;; *   **Conversion functions**: `array->vec2/3/4` and `seq->vec2/3/4` provide convenience for converting `double` arrays or arbitrary sequences into the fixed-size types.

(utls/examples-note
  (v/vec2)
  (v/vec2 1 2)
  (class (v/vec2))
  (v/vec3)
  (v/vec3 V2 3)
  (v/vec3 1 2 3)
  (class (v/vec3))
  (v/vec4)
  (v/vec4 V2 3 4)
  (v/vec4 V3 4)
  (v/vec4 1 2 3 4)
  (class (v/vec4))
  (v/array-vec [1 2 3 4 5])
  (v/make-vector 1)
  (v/make-vector 2)
  (v/make-vector 3)
  (v/make-vector 4)
  (v/make-vector 5 [1 2 3 4 5 8])
  (class (v/make-vector 5 [1 2 3 4 5 8]))
  (v/generate-vec2 rand)
  (v/generate-vec3 (constantly 4))
  (v/generate-vec4 (comp m/sin rand))
  (v/array->vec2 (double-array [1 2 3 4 5]))
  (v/array->vec3 (double-array [1 2 3 4 5]))
  (v/array->vec4 (double-array [1 2 3 4 5]))
  (v/seq->vec2 [1 2 3 4 5])
  (v/seq->vec3 [1 2 3 4 5])
  (v/seq->vec4 [1 2 3 4 5]))

;; #### Conversion

;; `fastmath.vector` provides several functions to convert vectors between the supported types and representations, facilitating integration with other libraries or specific processing needs.

;; *   `vec->array`: Converts any vector type to a `double` array (`[D`).
;; *   `vec->seq`: Returns a standard Clojure lazy sequence representation of the vector. Note that all `fastmath.vector` types already implement `clojure.lang.Seqable` and `clojure.lang.Sequential`, so you can use the built-in `seq` function or treat them as sequences directly.
;; *   `real-vector` or`vec->RealVector`: Converts any vector type into an Apache Commons Math `RealVector` object, specifically an `ArrayRealVector`.
;; *   `vec->Vec`: Converts any vector type into a Clojure primitive vector (`Vec`), which is an optimized implementation of persistent vectors for numerical data.

(utls/examples-note
  (v/vec->array V2)
  (v/vec->seq V2)
  (v/vec->RealVector V2)
  (v/vec->Vec V2)
  (class (v/vec->Vec V2))
  (v/vec->array [1 2 3])
  (v/vec->seq [1 2 3])
  (v/vec->RealVector [1 2 3])
  (v/real-vector [1 2 3])
  (v/real-vector (double-array 4))
  (v/real-vector (seq (v/vec2 9 8)))
  (v/vec->Vec [1 2 3]))

;; `as-vec` creates a new vector of a specific type  using elements from `xs` sequence. If the sequence is shorter than the target vector's dimension, the remaining elements are filled with `0.0`. The first argument specifies the target type (by providing an instance of that type). In short: `as-vec` ensures a type and size of the first argument with the content of the second argument. 

(utls/examples-note
  (v/as-vec (list 3) [1 2 3])
  (v/as-vec (list 3 4 5) [1 2 3])
  (v/as-vec (list 3 4 5 6) [1 2 3])
  (v/as-vec (v/vec2) [1 2 3])
  (v/as-vec (v/vec3) [1 2 3])
  (v/as-vec (v/vec4) [1 2 3])
  (seq (v/as-vec (double-array 6) [1])))

;; ### Interoperability

;; The core idea behind `fastmath.vector`'s flexibility is the `fastmath.protocols/VectorProto` protocol. This protocol defines the common set of operations (addition, multiplication, dot product, magnitude, etc.) that all supported vector types must implement. By relying on this protocol, functions in `fastmath.vector` can work seamlessly with `Vec2`, `Vec3`, `Vec4`, `ArrayVec`, Clojure vectors, `double` arrays, and even Apache Commons Math `RealVector` instances. This protocol-oriented design allows for easy interoperability between different vector representations. Several functions are provided to facilitate conversions between these types:

;; Fixed-size vector types like `Vec2`, `Vec3`, and `Vec4`, as well as `ArrayVec`, also implement several standard Clojure and Java interfaces, allowing them to be used similarly to built-in Clojure persistent vectors:
;;
;; *   `clojure.lang.Seqable`: Enables treating the vector as a sequence for functions like `seq`, `map`, `filter`, etc.
;; *   `clojure.lang.Reversible`: Enables reversing a vector with `rseq`
;; *   `clojure.lang.Sequential`: Marks that the vector is sequential, ie. sequence is linear and order is persistent 
;; *   `clojure.lang.Indexed`: Allows efficient access to elements by integer index using `nth`.
;; *   `clojure.lang.ILookup`: Enables lookup of elements by index using the function call syntax `(v index)` or `get`.
;; *   `clojure.lang.Counted`: Provides the `count` function to get the dimension of the vector.
;; *   `clojure.lang.IFn`: Allows the vector itself to be invoked as a function to retrieve elements by index, e.g., `(v 0)`.
;; *   `clojure.lang.Associative`: Supports `assoc`, `containsKey`, and `entryAt`, allowing index-based association (updating elements). Note that `assoc` returns a new vector instance.
;; *   `clojure.lang.IReduce`/`IReduceInit`: Allows using `reduce` directly on the vector's elements.
;; *   `clojure.lang.IPersistentVector`: Implements basic persistent vector behavior.
;; *   `clojure.lang.IPersistentCollection`: Implements `equiv` for efficient structural equality checks.
;; *   `clojure.lang.IPersistentStack`: Implements `pop` and `peek`
;; *   `java.lang.Object`: Standard Java methods like `equals`, `hashCode`, and `toString`.
;; *   `clojure.lang.IHashEq`: Provides `hasheq` for efficient hashing, especially important when using vectors as keys in hash maps or sets.

(utls/callout "note" "Examples"
  (kind/md "`Seqable`")
  (utls/examples
    (seq V2)
    (seq V3)
    (seq V4)
    (map inc V4))
  (kind/md "`Reversible`")
  (utls/examples
    (rseq V2)
    (rseq V3)
    (rseq V4))
  (kind/md "`Indexed`")
  (utls/examples
    (nth V4 0)
    (try (nth V4 5) (catch Exception e (.getMessage e)))
    (nth V4 5 ##NaN))
  (kind/md "`ILookup`")
  (utls/examples
    (get V4 3)
    (get V4 5))
  (kind/md "`Counted`")
  (utls/examples
    (count V2)
    (count V3)
    (count V4))
  (kind/md "`IFn`")
  (utls/examples
    (V2 0)
    (V3 1)
    (V4 2)
    (try (V4 5) (catch Exception e (.getMessage e))))
  (kind/md "`Associative`")
  (utls/examples
    (contains? V4 0)
    (contains? V4 5)
    (assoc V4 3 100)
    (find V4 3))
  (kind/md "`IReduce/IReduceInit`")
  (utls/examples
    (reduce * V4)
    (reduce * 100 V4))
  (kind/md "`IPersistentVector`")
  (utls/examples
    (conj V2 100)
    (conj V3 100)
    (conj V4 100))
  (kind/md "`IPersistentStack`")
  (utls/examples
    (peek V2)
    (pop V2)
    (peek V3)
    (pop V3)
    (peek V4)
    (pop V4))
  (kind/md "`IPersistentCollection`")
  (utls/examples
    (= V2 (v/vec2 -1 2))
    (= V2 V3))
  (kind/md "`IHashEq`")
  (utls/examples
    (hash V2)
    (hash V3)
    (hash V4))
  (kind/md "`Object`")
  (utls/examples
    (str V2)
    (.equals V2 (v/vec2 -1 2))
    (.hashCode V2)))

;; ### Vector Arithmetic and Operations

;; `fastmath.vector` provides a comprehensive suite of functions for performing standard vector arithmetic and element-wise mathematical operations. These operations are designed to work efficiently and consistently across all supported vector types, leveraging the `VectorProto` protocol.

;; #### Basic operations

;; ::: {.callout-tip title="Defined functions"}
;; * `add`, `sub`, `shift`, `mult`, `div`, `reciprocal`, `emult`, `ediv`
;; * `abs`
;; * `mn`, `mx`, `emn`, `emx`, `mindim`, `maxdim`
;; * `approx`
;; * `sum`, `prod`, `average`, `logsumexp`, `logmeanexp`
;; * `zero-count`, `nonzero-count`, `size`
;; * `permute`
;; * `fmap`
;; :::

;; *   **Basic Arithmetic**:
;;     *   `add`: Vector addition. Takes one or two vectors. $\mathbf{u} + \mathbf{v} = [u_1+v_1, u_2+v_2, \dots, u_n+v_n]$.
;;     *   `sub`: Vector subtraction. Takes one (negation) or two vectors. $\mathbf{u} - \mathbf{v} = [u_1-v_1, u_2-v_2, \dots, u_n-v_n]$.
;;     *   `shift`: Adds a scalar value to each element of a vector. $\mathbf{v} + c = [v_1+c, v_2+c, \dots, v_n+c]$.
;;     *   `mult`: Scalar multiplication of a vector. $c \mathbf{v} = [c v_1, c v_2, \dots, c v_n]$.
;;     *   `div`: Scalar division of a vector (`v1 / v`) or element-wise reciprocal (`v1`). $\mathbf{v} / c = [v_1/c, v_2/c, \dots, v_n/c]$ or $1/\mathbf{v} = [1/v_1, 1/v_2, \dots, 1/v_n]$.
;;     *   `reciprocal`: Element-wise reciprocal. $1/\mathbf{v} = [1/v_1, 1/v_2, \dots, 1/v_n]$.
;;     *   `emult`: Element-wise multiplication (Hadamard product). $\mathbf{u} \odot \mathbf{v} = [u_1 v_1, u_2 v_2, \dots, u_n v_n]$.
;;     *   `ediv`: Element-wise division. $\mathbf{u} \oslash \mathbf{v} = [u_1/v_1, u_2/v_2, \dots, u_n/v_n]$.
;; *   **Element-wise Functions**:
;;     *   `abs`: Element-wise absolute value. $|\mathbf{v}| = [|v_1|, |v_2|, \dots, |v_n|]$.
;;     *   `fmap`: Applies a function to each element of the vector, returning a new vector of the same type. $f(\mathbf{v}) = [f(v_1), f(v_2), \dots, f(v_n)]$.
;; *   **Statistical/Aggregate Functions**:
;;     *   `mn`: Minimum value among elements.
;;     *   `mx`: Maximum value among elements.
;;     *   `emn`: Element-wise minimum of two vectors.
;;     *   `emx`: Element-wise maximum of two vectors.
;;     *   `mindim`: Index of the minimum value.
;;     *   `maxdim`: Index of the maximum value.
;;     *   `sum`: Sum of all elements. $\sum \mathbf{v} = \sum_{i=1}^n v_i$.
;;     *   `prod`: Product of all elements. $\prod \mathbf{v} = \prod_{i=1}^n v_i$.
;;     *   `average`: Mean or weighted average of elements. $\text{mean}(\mathbf{v}) = \frac{1}{n} \sum_{i=1}^n v_i$.
;;     *   `logsumexp`: Numerically stable computation of $\log(\sum \exp(v_i))$.
;;     *   `logmeanexp`: Numerically stable computation of $\log(\frac{1}{n} \sum \exp(v_i))$.
;; *   **Utility Functions**:
;;     *   `approx`: Rounds elements to a specified number of decimal places.
;;     *   `zero-count`: Counts how many elements are approximately zero.
;;     *   `nonzero-count`: Counts how many elements are not approximately zero.
;;     *   `size`: Returns the dimension (number of elements) of the vector. Same as `count`.
;;     *   `permute`: Rearranges vector elements according to a list of indices.
;;
;; Most binary operations (`add`, `sub`, `emult`, `ediv`, `emn`, `emx`) require the input vectors to have the same dimension and type. Scalar operations (`shift`, `mult`, `div`) work with a vector and a number.

(utls/examples-note
  (v/add V2 (v/vec2 1 1))
  (v/sub V3 (v/vec3 1 1 1))
  (v/shift V4 10.0)
  (v/mult V3 0.5)
  (v/div V4 2.0)
  (v/div V3)
  (v/reciprocal V3)
  (v/emult V2 (v/vec2 2 2))
  (v/ediv V2 (v/vec2 2 10))
  (v/abs V4)
  (v/mn V3)
  (v/mx V4)
  (v/emn V3 (v/vec3 0 3 -4))
  (v/emx V4 (v/vec4 -2 1 -3 5))
  (v/mindim V4)
  (v/maxdim V4)
  (v/sum)
  (v/sum V2)
  (v/prod)
  (v/prod V3)
  (v/average V4)
  (v/average V4 (v/vec4 1 1 10 1))
  (v/approx (v/vec4 1.2345 6.789 0.123 4.567))
  (v/approx (v/vec4 1.2345 6.789 0.123 4.567) 1)
  (v/zero-count V4)
  (v/nonzero-count V4)
  (v/size V3)
  (count V3)
  (v/permute V4 [3 1 0 2])
  (v/permute V4 [0 0 0 3])
  (v/fmap V3 m/cos)
  (v/logsumexp [-10 10 20 30 40])
  (v/logmeanexp [-10 10 20 30 40]))

;; #### Comparison and Equality
;;
;; Functions for comparing vectors, including approximate equality checks. These functions are essential for robust numerical comparisons, especially when dealing with floating-point numbers where exact equality (`=`) can be unreliable due to precision issues.
;;
;; ::: {.callout-tip title="Defined functions"}
;; * `is-zero?`, `zero?`, `is-near-zero?`, `near-zero?`
;; * `delta-eq`, `edelta-eq`
;; * `aligned?`
;; :::

;; *   **Zero Check**:
;;     *   `is-zero?` / `zero?`: Checks if all elements of the vector are exactly zero. Returns `true` if $\mathbf{v} = [0, 0, \dots, 0]$.
;;     *   `is-near-zero?` / `near-zero?`: Checks if the vector's magnitude is close to zero within a specified absolute or relative tolerance. Returns `true` if $\Vert \mathbf{v} \Vert \approx 0$.
;; *   **Equality Check**:
;;     *   `delta-eq`: Checks if the Euclidean distance between two vectors is within a given absolute and/or relative tolerance. Returns `true` if $\Vert \mathbf{u} - \mathbf{v} \Vert \approx 0$.
;;     *   `edelta-eq`: Performs an element-wise approximate equality check between two vectors. Returns `true` if $|u_i - v_i| \approx 0$ for all elements $i$, considering tolerance.
;; *   **Alignment Check**:
;;     *   `aligned?`: Checks if the angle between two vectors is less than a specified tolerance, indicating they point in approximately the same direction. Returns `true` if Angle$(\mathbf{u}, \mathbf{v}) < \text{tolerance}$.

(utls/examples-note
  (v/is-zero? (v/vec2))
  (v/zero? (v/vec3 0 0 0))
  (v/is-zero? V2)
  (v/near-zero? (v/vec4 1e-9 0 0 -1e-9))
  (v/near-zero? (v/vec4 1e-5 0 0 -1e-5) 1e-6)
  (v/near-zero? (v/vec4 1e-5 0 0 -1e-5) 1e-4)
  (v/delta-eq V2 (v/vec2 -1.0 2.5))
  (v/delta-eq V2 (v/vec2 -1.0000001 2.5000001))
  (v/delta-eq V2 (v/vec2 -1.000001 2.500001) 1e-6)
  (v/edelta-eq V2 (v/vec2 -1.0 2.5))
  (v/edelta-eq V2 (v/vec2 -1.0000001 2.5000001))
  (v/edelta-eq V2 (v/vec2 -1.000001 2.500001) 1e-6)
  (v/aligned? (v/vec2 1 0) (v/vec2 1 1e-7))
  (v/aligned? (v/vec2 1 0) (v/vec2 1 1e-5))
  (v/aligned? (v/vec2 1 0) (v/vec2 1 1e-5) 1e-4))

;; #### Interpolation and Clamping
;;
;; Functions for blending vectors and bounding element values.
;;
;; ::: {.callout-tip title="Defined functions"}
;; * `interpolate`, `einterpolate`, `lerp`
;; * `econstrain`, `clamp`
;; :::

;; These functions provide tools for combining vectors based on a parameter (interpolation) or ensuring that vector elements stay within specified bounds (clamping and constraining).
;;
;; *   **Interpolation**:
;;     *   `interpolate`: Blends two vectors `v1` and `v2` based on a scalar parameter `t`. The default interpolation function is linear interpolation (`lerp`).
;;     *   `einterpolate`: Performs element-wise interpolation between vectors `v1` and `v2`, using corresponding elements from a third vector `v` as the interpolation parameters `t`.
;;     *   `lerp`: Performs linear interpolation between two vectors $\mathbf{v}_1$ and $\mathbf{v}_2$. The resulting vector is $\mathbf{v}_1 + t (\mathbf{v}_2 - \mathbf{v}_1)$. This is a specific case of `interpolate` using the standard `fastmath.core/lerp` function.
;; *   **Clamping/Constraining**:
;;     *   `econstrain`: Clamps each element of a vector `v` between a minimum value `val1` and a maximum value `val2` element-wise.
;;     *   `clamp`: A convenience function that uses `econstrain`. It clamps elements between 0.0 and `Double/MAX_VALUE` when called with one argument `[v]`, or between `mn` and `mx` when called with three arguments `[v mn mx]`.

(utls/examples-note
  (v/lerp (v/vec2) (v/vec2 10 -10) 0.5)
  (v/interpolate (v/vec4) (v/vec4 1 1 1 1) 0.75)
  (v/interpolate (v/vec4) (v/vec4 1 1 1 1) 0.75 m/smoothstep)
  (v/einterpolate (v/vec2) (v/vec2 10 -10) (v/vec2 0.2 0.8))
  (v/einterpolate (v/vec4) (v/vec4 1 1 1 1) (v/vec4 0 0.2 0.8 1) m/smoothstep)
  (v/econstrain (v/vec4 -2 0.5 5 1.2) 0.0 1.0)
  (v/clamp (v/vec3 -5 10 0.5) 0 1)
  (v/clamp (v/vec3 -5 10 0.5)))

;; #### Element-wise Functions
;;
;; Applying common mathematical functions from `fastmath.core` element-wise.
;;
;; ::: {.callout-tip title="Defined functions"}
;; * `sin`, `cos`, `tan`, `asin`, `acos`, `atan`
;; * `sinh`, `cosh`, `tanh`, `asinh`, `acosh`, `atanh`
;; * `cot`, `sec`, `csc`, `acot`, `asec`, `acsc`
;; * `coth`, `sech`, `csch`, `acoth`, `asech`, `acsch`
;; * `sq`, `cb`, `safe-sqrt`, `sqrt`, `cbrt`, `pow`
;; * `exp`, `log`, `log10`, `log2`, `ln`, `log1p`, `expm1`
;; * `log1pexp`, `log1mexp`, `log1psq`, `log1pmx`, `logmxp1`, `logexpm1`
;; * `radians`, `degrees`, `sinc`, `sigmoid`, `logit`, `xlogx`
;; * `floor`, `ceil`, `round`, `rint`, `trunc`, `frac`, `sfrac`, `signum`, `sgn`
;; :::

(utls/callout "note" "Examples"
  (kind/md "Trigonometry")
  (utls/examples
    (v/sin V2)
    (v/cos V2)
    (v/tan V2)
    (v/cot V2)
    (v/sec V2)
    (v/csc V2)
    (v/asin (v/vec2 -0.5 0.5))
    (v/acos (v/vec2 -0.5 0.5))
    (v/atan (v/vec2 -0.5 0.5))
    (v/acot (v/vec2 -0.5 0.5))
    (v/asec (v/vec2 1 2))
    (v/acsc (v/vec2 1 2)))
  (kind/md "Hyperbolic")
  (utls/examples
    (v/sinh V2)
    (v/cosh V2)
    (v/tanh V2)
    (v/coth V2)
    (v/sech V2)
    (v/csch V2)
    (v/asinh (v/vec2 -0.5 0.5))
    (v/acosh (v/vec2 1 2))
    (v/atanh (v/vec2 -0.5 0.5))
    (v/acoth (v/vec2 1 2))
    (v/asech (v/vec2 1 0.5))
    (v/acsch (v/vec2 1 2)))
  (kind/md "Powers")
  (utls/examples
    (v/sq V3)
    (v/cb V3)
    (v/safe-sqrt V3)
    (v/sqrt V3)
    (v/cbrt V3)
    (v/pow V3 5))
  (kind/md "Exp and logarithm")
  (utls/examples
    (v/exp V3)
    (v/expm1 V3)
    (v/log (v/abs V3))
    (v/ln (v/abs V3))
    (v/log10 (v/abs V3))
    (v/log2 (v/abs V3))
    (v/log1p (v/abs V3))
    (v/log1pexp V3)
    (v/log1mexp V3)
    (v/log1psq V3)
    (v/log1pmx V3)
    (v/logmxp1 V3)
    (v/logexpm1 V3)
    (v/xlogx (v/abs V3)))
  (kind/md "Sign")
  (utls/examples
    (v/signum V4)
    (v/sgn V4))
  (kind/md "Rounding")
  (utls/examples
    (v/floor V4)
    (v/ceil V4)
    (v/round V4)
    (v/rint V4)
    (v/trunc V4)
    (v/frac V4)
    (v/sfrac V4))
  (kind/md "Other")
  (utls/examples
    (v/radians V3)
    (v/degrees V3)
    (v/sinc V3)
    (v/sigmoid V3)
    (v/logit (v/vec3 0.1 0.5 0.9))))

;; ### Geometric Properties and Operations
;;
;; Functions related to the length, direction, and orientation of vectors.
;;
;; ::: {.callout-tip title="Defined functions"}
;; * `mag`, `magsq`
;; * `normalize`, `set-mag`, `limit`
;; * `heading`, `angle-between`, `relative-angle-between`
;; * `perpendicular`, `base-from`, `faceforward`, `project`
;; * `transform`
;; * `average-vectors`
;; * `dot`, `cross`, `triple-product`
;; * `rotate`, `axis-rotate`
;; * `to-polar`, `from-polar`
;; :::

;; These functions allow you to compute vector lengths, angles between vectors, project one vector onto another, normalize vectors, perform rotations, and work with different coordinate representations.
;;
;; *   **Magnitude and Length**:
;;     *   `magsq`: Computes the squared Euclidean magnitude (length) of a vector. $\Vert \mathbf{v} \Vert^2 = \sum_{i=1}^n v_i^2$. Useful for comparisons as it avoids the expensive square root calculation.
;;     *   `mag`: Computes the Euclidean magnitude (length) of a vector. $\Vert \mathbf{v} \Vert = \sqrt{\sum_{i=1}^n v_i^2}$.
;; *   **Normalization and Scaling**:
;;     *   `normalize`: Returns a unit vector (magnitude 1) with the same direction as the input vector. $\hat{\mathbf{v}} = \mathbf{v} / \Vert \mathbf{v} \Vert$. Returns a zero vector if the input is a zero vector.
;;     *   `set-mag`: Returns a new vector with the same direction as the input vector but a specified magnitude. $\mathbf{v}' = \text{len} \cdot \hat{\mathbf{v}}$.
;;     *   `limit`: Returns a new vector with the same direction as the input, but limits its magnitude to a maximum value. If the current magnitude is less than the limit, the original vector is returned.
;; *   **Angles and Direction**:
;;     *   `heading`: For 2D vectors, returns the angle (in radians) relative to the positive x-axis. For 3D/4D vectors, it returns the angle between the vector and the positive x-axis (`[1,0,...]`).
;;     *   `angle-between`: Computes the angle (in radians, $0 \le \theta \le \pi$) between two vectors. $\theta = \operatorname{acos}(\frac{\mathbf{u} \cdot \mathbf{v}}{\Vert \mathbf{u} \Vert \Vert \mathbf{v} \Vert})$. Returns 0 if either vector is zero.
;;     *   `relative-angle-between`: Computes the difference between the `heading` of two vectors. Primarily useful for 2D vectors to find the signed angle difference. Returns a value from $-2\pi$ to $2\pi$.
;; *   **Projections and Basis**:
;;     *   `project`: Computes the vector projection of `v1` onto `v2`. This is the component of `v1` that lies along the direction of `v2`. $\text{proj}_{\mathbf{v}_2} \mathbf{v}_1 = \frac{\mathbf{v}_1 \cdot \mathbf{v}_2}{\Vert \mathbf{v}_2 \Vert^2} \mathbf{v}_2$.
;;     *   `perpendicular`: For 2D vectors, returns a vector perpendicular to the input (`[-y, x]`). For 3D vectors, `perpendicular(v1, v2)` computes a vector perpendicular to both `v1` and `v2` (their normalized cross product). Only defined for `Vec2` and `Vec3`.
;;     *   `base-from`: Computes an orthogonal basis starting from the input vector. For `Vec2`, returns `[v, perpendicular(v)]`. For `Vec3`, returns `[v, v', v'']` where `v'` and `v''` are orthogonal to `v` and each other. Only defined for `Vec2` and `Vec3`.
;;     *   `faceforward`: Returns vector `n` or `-n` such that it faces the same general direction as `v`. Specifically, if $\mathbf{n} \cdot \mathbf{v} < 0$, returns $-\mathbf{n}$; otherwise, returns $\mathbf{n}$. Useful for ensuring normals face outwards or towards a view direction.
;; *   **Transformations**:
;;     *   `transform`: Transforms a point (represented by a vector `v`) from one coordinate system to another defined by an origin `o` and basis vectors (`vx`, `vy`, `vz`). Only defined for `Vec2` and `Vec3`.
;; *   **Aggregate/Statistical (Geometric Context)**:
;;     *   `average-vectors`: Computes the centroid (average position) of a collection of vectors.
;; *   **Vector Products**:
;;     *   `dot`: Computes the dot product of two vectors. $\mathbf{u} \cdot \mathbf{v} = \sum_{i=1}^n u_i v_i$. Returns a scalar value.
;;     *   `cross`: Computes the cross product of two 3D vectors. $\mathbf{u} \times \mathbf{v} = [u_y v_z - u_z v_y, u_z v_x - u_x v_z, u_x v_y - u_y v_x]$. Returns a vector perpendicular to both inputs. Only defined for `Vec3`.
;;     *   `triple-product`: Computes the scalar triple product of three 3D vectors: $\mathbf{a} \cdot (\mathbf{b} \times \mathbf{c})$. Returns a scalar value equal to the signed volume of the parallelepiped spanned by the vectors. Only defined for `Vec3`.
;; *   **Rotations**:
;;     *   `rotate`: Rotates a 2D vector by a given angle around the origin. Rotates a 3D vector around the origin by specified angles around the x, y, and z axes (intrinsic ZYX rotation). Only defined for `Vec2` and `Vec3`.
;;     *   `axis-rotate`: Rotates a 3D vector around a specified axis by a given angle. Can also specify an optional pivot point. Only defined for `Vec3`.
;; *   **Coordinate Systems**:
;;     *   `to-polar`: Converts a 2D vector (`[x, y]`) to polar coordinates (`[r, \theta]`) or a 3D vector (`[x, y, z]`) to spherical coordinates (`[r, \theta, \phi]`), where `r` is magnitude, `\theta` is the angle from the positive z-axis (for 3D) or x-axis (for 2D), and `\phi` is the azimuthal angle in the xy-plane (for 3D). Only defined for `Vec2` and `Vec3`.
;;     *   `from-polar`: Converts a vector from polar (2D) or spherical (3D) coordinates back to Cartesian coordinates. Assumes input elements represent `[r, \theta]` for 2D or `[r, \theta, \phi]` for 3D. Only defined for `Vec2` and `Vec3`.

(utls/examples-note
  (v/magsq V3)
  (v/mag V3)
  (v/normalize V3)
  (v/set-mag V3 10.0)
  (v/limit V3 2.0)
  (v/heading V2)
  (v/angle-between (v/vec2 1 0) (v/vec2 0 1))
  (v/relative-angle-between (v/vec2 1 0) (v/vec2 0 1))
  (v/project V3 (v/vec3 1 1 1))
  (v/project (v/vec3 1 1 1) V3)
  (v/perpendicular (v/vec2 1 0))
  (v/perpendicular V3 (v/vec3 0 0 1))
  (v/base-from V2)
  (v/base-from V3)
  (v/faceforward (v/vec3 0 0 1) (v/vec3 0 0 -1))
  (v/faceforward (v/vec3 0 0 1) (v/vec3 0 0 1))
  (v/transform (v/vec2 1 1) (v/vec2 10 10) (v/vec2 1 0) (v/vec2 0 1))
  (v/transform (v/vec3 1 1 1) (v/vec3 10 10 10) (v/vec3 1 0 0) (v/vec3 0 1 0) (v/vec3 0 0 1))
  (v/average-vectors [V2 (v/vec2 1 1) (v/vec2 -2 -2)])
  (v/dot V3 (v/vec3 1 1 1))
  (v/dot V3 (v/perpendicular V3 (v/vec3 0 0 1)))
  (v/cross (v/vec3 1 0 0) (v/vec3 0 1 0))
  (v/triple-product (v/vec3 1 0 0) (v/vec3 0 1 0) (v/vec3 0 0 1))
  (v/rotate V2 m/HALF_PI)
  (v/rotate V3 m/HALF_PI 0 0)
  (v/axis-rotate V3 m/HALF_PI (v/vec3 1 0 0))
  (v/axis-rotate (v/vec3 1 1 1) m/HALF_PI (v/vec3 0 0 1) (v/vec3 0 0 0)) ;; rotation around origin
  (v/axis-rotate (v/vec3 1 1 1) m/HALF_PI (v/vec3 0 0 1) (v/vec3 1 1 0)) ;; rotation around pivot
  (v/to-polar V2)
  (v/from-polar (v/vec2 (v/mag V2) (v/heading V2)))
  (v/to-polar V3)
  (v/from-polar (v/vec3 (v/mag V3) 2.45 1.95)))

;; ### Distances and Similarities
;;
;; Functions for measuring the distance or similarity between vectors using various metrics.
;;
;; ::: {.callout-tip title="Defined functions"}
;; * `dist`, `dist-sq`
;; * `dist-abs`, `dist-cheb`
;; * `dist-discrete`
;; * `dist-canberra`, `dist-emd`
;; * `dist-ang`, `sim-cos`
;; * `distances`
;; :::

;; These functions provide ways to quantify how "far apart" two vectors are (distance) or how similar their directions are (similarity), based on different mathematical definitions.
;;
;; *   **Euclidean Distance**:
;;     *   `dist`: Computes the standard Euclidean distance between two vectors. $\Vert \mathbf{u} - \mathbf{v} \Vert = \sqrt{\sum_{i=1}^n (u_i - v_i)^2}$.
;;     *   `dist-sq`: Computes the squared Euclidean distance. $\Vert \mathbf{u} - \mathbf{v} \Vert^2 = \sum_{i=1}^n (u_i - v_i)^2$. Faster than `dist` if only comparing distances.
;; *   **Other Common Distances**:
;;     *   `dist-abs`: Computes the Manhattan distance (L1 norm of the difference). $\sum_{i=1}^n |u_i - v_i|$.
;;     *   `dist-cheb`: Computes the Chebyshev distance (L-infinity norm of the difference). $\max_{i} |u_i - v_i|$.
;;     *   `dist-discrete`: Computes the discrete distance (Hamming distance for numerical vectors), counting the number of elements that are approximately different. $\sum_{i=1}^n \mathbb{I}(|u_i - v_i| > \epsilon)$.
;;     *   `dist-canberra`: Computes the Canberra distance. $\sum_{i=1}^n \frac{|u_i - v_i|}{|u_i| + |v_i|}$, handles division by zero by treating $\frac{0}{0}$ as 0.
;;     *   `dist-emd`: Computes the 1D Earth Mover's Distance (Wasserstein distance) between two vectors treated as 1D distributions. It is calculated as the sum of absolute differences of their cumulative sums. $\sum_{i=1}^n \left| \sum_{j=1}^i u_j - \sum_{j=1}^i v_j \right|$.
;; *   **Angular Metrics**:
;;     *   `dist-ang`: Computes the angular distance, which is the angle between normalized vectors, scaled to the range $[0, 1]$ by dividing by $\pi$. $\frac{1}{\pi} \operatorname{acos}(\frac{\mathbf{u} \cdot \mathbf{v}}{\Vert \mathbf{u} \Vert \Vert \mathbf{v} \Vert})$.
;;     *   `sim-cos`: Computes the cosine similarity between two vectors. This is the cosine of the angle between them. $\frac{\mathbf{u} \cdot \mathbf{v}}{\Vert \mathbf{u} \Vert \Vert \mathbf{v} \Vert}$. A value of 1 indicates identical direction, -1 opposite, and 0 orthogonality.
;; *   **Distance Map**:
;;     *   `distances`: A map where keys are keywords (e.g., `:euclid`, `:abs`) and values are the corresponding distance functions. Useful for selecting metrics programmatically.

(utls/examples-note
  (v/dist V2 (v/vec2 0 0))
  (v/dist V3 (v/vec3 1 2 3))
  (v/dist-sq V2 (v/vec2 0 0))
  (v/dist-sq V3 (v/vec3 1 2 3))
  (v/dist-abs V4 (v/vec4 0 0 0 0))
  (v/dist-abs V4 (v/vec4 -1 1 -3 5))
  (v/dist-cheb V4 (v/vec4 0 0 0 0))
  (v/dist-cheb V4 (v/vec4 -1 1 -3 5))
  (v/dist-discrete V3 (v/vec3 -1 2.5 -3.25)) 
  (v/dist-discrete V3 (v/vec3 -1 2.5 -3.251) 0.0001)
  (v/dist-discrete V3 (v/vec3 -1 2.5 -3.251) 0.001)
  (v/dist-discrete V3 (v/vec3 -1 0 -3.25))
  (v/dist-canberra V3 (v/vec3 1 1 1))
  (v/dist-canberra (v/vec3 1 0 1) (v/vec3 0 1 0))
  (v/dist-emd (v/vec3 1 2 3) (v/vec3 3 2 1))
  (v/dist-ang (v/vec2 1 0) (v/vec2 0 1))
  (v/dist-ang (v/vec3 1 0 0) (v/vec3 0 0 1))
  (v/sim-cos (v/vec2 1 0) (v/vec2 0 1)) 
  (v/sim-cos (v/vec2 1 0) (v/vec2 -1 0))
  ((v/distances :euclid) V3 (v/vec3 1 2 3))
  ((v/distances :abs) V4 (v/vec4 -1 1 -3 5)))

(keys v/distances)

;; ### Advanced and Specific Operations
;;
;; Other utility and more specialized vector operations.
;;
;; ::: {.callout-tip title="Defined Functions"}
;; * `orthogonal-polynomials`, `orthonormal-polynomials`
;; * `softmax`, `logsoftmax`
;; :::

;; This section covers advanced operations that are useful in specific mathematical or statistical contexts, such as generating orthogonal bases for polynomial fitting or numerical stability functions common in machine learning.

;; *   **Polynomial Bases**:
;;     *   `orthogonal-polynomials`: Generates a sequence of vectors representing orthogonal polynomials evaluated at the points in the input sequence `xs`. Orthogonality is with respect to the discrete inner product $\sum_i p_k(x_i) p_j(x_i) = 0$ for $k \ne j$. The sequence includes vectors up to degree `(count xs) - 1`.
;;     *   `orthonormal-polynomials`: Similar to `orthogonal-polynomials`, but normalizes each resulting vector to have unit magnitude. This creates an orthonormal basis.

(utls/zp (v/orthogonal-polynomials [1 2 3 4 5]))

(utls/zp (v/orthonormal-polynomials [1 2 3 4 5]))

;; *   **Softmax and Log-Softmax**:
;;     *   `softmax`: Applies the softmax function element-wise to a vector, converting arbitrary real values into a probability distribution. $\operatorname{softmax}(\mathbf{v})_i = \frac{\exp(v_i)}{\sum_j \exp(v_j)}$. Supports an optional temperature parameter `t`: $\operatorname{softmax}(\mathbf{v}, t)_i = \frac{\exp(v_i/t)}{\sum_j \exp(v_j/t)}$. It uses a numerically stable implementation.
;;     *   `logsoftmax`: Computes the element-wise natural logarithm of the softmax function in a numerically stable way. $\operatorname{logsoftmax}(\mathbf{v})_i = \log(\operatorname{softmax}(\mathbf{v})_i) = v_i - \log(\sum_j \exp(v_j))$. Also supports a temperature parameter `t`.

(utls/examples-note
  (v/softmax [1 2 3])
  (v/softmax [1 2 3] 0.5)
  (v/logsoftmax [1 2 3])
  (v/logsoftmax [1 2 3] 2.0))

;; ## Matrices

;; The `fastmath.matrix` namespace provides tools for working with 2x2, 3x3, 4x4 fixed-size matrices and arbitrary-sized matrices represented as Java `double[][]` arrays or Apache Commons Math `RealMatrix`. It is designed to provide efficient mathematical operations for linear algebra, geometric transformations, and data preprocessing.

;; ### Supported Matrix Types

;; `fastmath.matrix` works with several matrix representations, balancing convenience, performance, and compatibility.

;; ::: {.callout-tip title="Supported Types"}
;; * `Mat2x2` (2x2 matrix, custom type)
;; * `Mat3x3` (3x3 matrix, custom type)
;; * `Mat4x4` (4x4 matrix, custom type)
;; * `double[][]` (Java 2D double array, N x M)
;; * `org.apache.commons.math3.linear.RealMatrix` (N x M)
;; :::

(def M2x2 (Mat2x2. 1 2 3 4))
(def M3x3 (Mat3x3. 1 2 3 -4 5 6 9 -8 7))
(def M4x4 (Mat4x4. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16))
(def RealMat (mat/real-matrix [[1 2 3] [4 5 6]]))

M2x2 M3x3 M4x4 RealMat

;; ### Creation and Conversion

;; Functions for generating new matrices or converting between the supported types and standard Clojure/Java representations.

;; ::: {.callout-tip title="Defined functions"}
;; * `mat2x2`, `mat3x3`, `mat4x4`
;; * `rows->mat2x2`, `rows->mat3x3`, `rows->mat4x4`
;; * `cols->mat2x2`, `cols->mat3x3`, `cols->mat4x4`
;; * `diag->mat2x2`, `diag->mat3x3`, `diag->mat4x4`
;; * `real-matrix`, `rows->RealMatrix`, `cols->RealMatrix`
;; * `mat`, `rows->mat`, `cols->mat`
;; * `array2d->mat2x2`, `array2d->mat3x3`, `array2d->mat4x4`, `array2d->RealMatrix`
;; * `mat->seq`, `mat->array2d`, `mat->float-array2d`, `mat->array`, `mat->float-array`, `mat->RealMatrix`
;; * `eye`, `zero`, `diagonal`
;; :::

;; #### Creating Fixed-Size Matrices

;; Use `mat2x2`, `mat3x3`, `mat4x4` for creating small, performance-optimized matrices.

;; :::: {.grid}

;; ::: {.g-col-4}
;; **Single value**
(mat/mat2x2 1)
;; ---
(mat/mat3x3 2)
;; ---
(mat/mat4x4 3)
;; :::

;; ::: {.g-col-4}
;; **Diagonal**
(mat/mat2x2 2 -2)
;; ---
(mat/mat3x3 2 -2 1)
;; ---
(mat/mat4x4 2 -2 1 3)
;; :::

;; ::: {.g-col-4}
;; **Full matrix**
(mat/mat2x2 1 2 3 4)
;; ---
(mat/mat3x3 1 2 3 4 5 6 7 8 9)
;; ---
(mat/mat4x4 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6)
;; :::

;; ::::

;; Additionally you can use specialized creation functions from rows, cols or diagonals.

;; :::: {.grid}

;; ::: {.g-col-6}
;; **Matrices from rows**
(mat/rows->mat2x2 [1 2]
                  [5 6])
;; ---
(mat/rows->mat3x3 [1 2 3]
                  [4 5 6]
                  [7 8 9])
;; ---
(mat/rows->mat4x4 [1 2 3 4]
                  [5 6 7 8]
                  [9 0 1 2]
                  [3 4 5 6])
;; :::

;; ::: {.g-col-6}
;; **Matrices from columns**
(mat/cols->mat2x2 [1 2]
                  [5 6])
;; ---
(mat/cols->mat3x3 [1 2 3]
                  [4 5 6]
                  [7 8 9])
;; ---
(mat/cols->mat4x4 [1 2 3 4]
                  [5 6 7 8]
                  [9 0 1 2]
                  [3 4 5 6])
;; :::

;; ::::

;; :::: {.grid}

;; ::: {.g-col-6}
;; **Single value diagonal**
(mat/diag->mat2x2 1)
;; ---
(mat/diag->mat3x3 1)
;; ---
(mat/diag->mat4x4 1)
;; :::

;; ::: {.g-col-6}
;; **Full diagonals**
(mat/diag->mat2x2 1 2)
;; ---
(mat/diag->mat3x3 1 2 3)
;; ---
(mat/diag->mat4x4 1 2 3 4)
;; :::

;; ::::


;; #### Creating Arbitrary-Size Matrices

;; Use `real-matrix`, `rows->RealMatrix`, `cols->RealMatrix` for N x M matrices backed by Apache Commons Math.

(mat/real-matrix [[1 2 3 4] [5 6 7 8]])

(mat/rows->RealMatrix [[1 2 3 4] [5 6 7 8]])

(mat/cols->RealMatrix [[1 2 3 4] [5 6 7 8]])

;; #### Generic Creation

;; The `mat`, `rows->mat`, and `cols->mat` functions provide convenient constructors that automatically choose the fixed-size type for 2x2, 3x3, or 4x4 inputs, or default to `RealMatrix` for others.

;; :::: {.grid}

;; ::: {.g-col-4}
;; **Matrices from values**
(mat/mat 1 2
         3 4)
;; ---
(mat/mat 1 2 3
         4 5 6
         7 8 9)
;; ---
(mat/mat 1 2 3 4
         5 6 7 8
         9 0 1 2
         3 4 5 6)
;; ---
(mat/mat [[1 2 3 4]
          [5 6 7 8]])
;; :::

;; ::: {.g-col-4}
;; **Matrices from rows**
(mat/rows->mat [1 2]
               [5 6])
;; ---
(mat/rows->mat [1 2 3]
               [4 5 6]
               [7 8 9])
;; ---
(mat/rows->mat [1 2 3 4]
               [5 6 7 8]
               [9 0 1 2]
               [3 4 5 6])
;; ---
(mat/rows->mat [[1 2 3 4]
                [5 6 7 8]])
;; :::

;; ::: {.g-col-4}
;; **Matrices from columns**
(mat/cols->mat [1 2]
               [5 6])
;; ---
(mat/cols->mat [1 2 3]
               [4 5 6]
               [7 8 9])
;; ---
(mat/cols->mat [1 2 3 4]
               [5 6 7 8]
               [9 0 1 2]
               [3 4 5 6])
;; ---
(mat/cols->mat [[1 2 3 4]
                [5 6 7 8]])

;; :::

;; ::::

;; #### Conversion to/from Arrays and Sequences

;; Functions like `array2d->mat2x2`, `mat->seq`, `mat->array2d`, etc., facilitate conversions between `fastmath.matrix` types and primitive arrays or Clojure sequences.

(def dda (m/seq->double-double-array [[1 2 3 4] [5 6 7 8] [9 0 1 2] [3 4 5 6]]))

dda

;; :::: {.grid}

;; ::: {.g-col-6}
(mat/array2d->mat2x2 dda)
;; ::: 

;; ::: {.g-col-6}
(mat/array2d->mat3x3 dda)
;; ::: 

;; ::: {.g-col-6}
(mat/array2d->mat4x4 dda)
;; ::: 

;; ::: {.g-col-6}
(mat/array2d->RealMatrix dda)
;; ::: 

;; ::::

(utls/examples-note
  (mat/mat->seq M3x3)
  (mat/mat->array M2x2)
  (mat/mat->array2d M2x2)
  (mat/mat->RealMatrix M2x2)
  (mat/mat->float-array M2x2)
  (mat/mat->float-array2d M2x2)
  (seq (mat/mat->array M2x2))
  (m/double-double-array->seq (mat/mat->array2d M2x2)))

;;

;; #### Special Matrices

;; * `eye` creates an identity matrix. When argument is between 2 and 4, creates fixed size types unless `real-matrix` is set to `true`.
;; * `zero` creates a zero matrix. When argument is between 2 and 4, creates fixed size types unless `real-matrix` is set to `true`.
;; * `diagonal` creates a diagonal matrix from a vector or sequence of values.

;; :::: {.grid}

;; ::: {.g-col-4}
;; **Identity matrix**
(mat/eye 2)
(mat/eye 3)
(mat/eye 4)
(mat/eye 2 true)
;; :::

;; ::: {.g-col-4}
;; **Zero**
(mat/zero 2)
(mat/zero 3)
(mat/zero 4)
(mat/zero 2 true)
(mat/zero 2 2 false)
(mat/zero 2 2 true)
;; :::

;; ::: {.g-col-4}
;; **Diagonal**
(mat/diagonal 1 2)
(mat/diagonal 1 2 3)
(mat/diagonal 1 2 3 4)
(mat/diagonal [1 2])
;; :::

;; ::::

;; ### Interoperability

;; Like vectors, the `fastmath.matrix` types (`Mat2x2`, `Mat3x3`, `Mat4x4`) implement several standard Clojure and Java interfaces. This allows them to be treated as collections of numbers, integrating smoothly with built-in Clojure functions and providing familiar access patterns. This interoperability complements the type-specific and protocol-based operations defined in `fastmath.matrix`.
;;
;; *   `java.lang.Object`: Standard Java methods like `equals`, `hashCode`, and `toString`.
;; *   `clojure.lang.IHashEq`: Provides `hasheq` for efficient hashing, enabling use as keys in hash maps or elements in sets.
;; *   `clojure.lang.Seqable`: Enables treating the matrix elements (in row-major order) as a sequence for functions like `seq`, `map`, `filter`, etc.
;; *   `clojure.lang.Reversible`: Allows reversing the sequence of elements with `rseq`.
;; *   `clojure.lang.Counted`: Provides the `count` function to get the total number of elements (`rows * cols`).
;; *   `clojure.lang.ILookup`: Enables lookup of elements by linear index using `get` or function call syntax `(m index)`. Also supports lookup by a `[row col]` tuple.
;; *   `clojure.lang.IFn`: Allows the matrix itself to be invoked as a function to retrieve elements by `[row col]` tuple `(m [row col])` or two arguments `(m row col)`.

(utls/callout "note" "Examples"
  (kind/md "`Seqable`")
  (utls/examples
    (seq M2x2)
    (seq M3x3)
    (seq M4x4)
    (map inc M4x4))
  (kind/md "`Reversible`")
  (utls/examples
    (rseq M2x2)
    (rseq M3x3)
    (rseq M4x4))
  (kind/md "`Counted`")
  (utls/examples
    (count M2x2)
    (count M3x3)
    (count M4x4))
  (kind/md "`ILookup`")
  (utls/examples
    (get M4x4 [0 0])
    (get M4x4 [3 3])
    (get M4x4 [5 5]))
  (kind/md "`IFn`")
  (utls/examples
    (M2x2 [0 0])
    (M3x3 [1 2])
    (M4x4 [3 3])
    (try (M4x4 [5 5]) (catch Exception e (.getMessage e))))
  (kind/md "`IHashEq`")
  (utls/examples
    (.hashCode M3x3)
    (hash M3x3))
  (kind/md "`Object`")
  (utls/examples
    (str M2x2)
    (.equals M2x2 (mat/mat2x2 1 2 3 4))))

;; ### Accessing Elements and Properties

;; Functions to retrieve matrix elements, rows, or columns, and to query matrix properties like size, shape, symmetry, determinant, and trace.

;; #### Element, Row, and Column Access

;; Functions to retrieve individual matrix elements or extract entire rows or columns as vectors. These are fundamental for inspecting and manipulating matrix data.

;; ::: {.callout-tip title="Defined functions"}
;; * `entry`, `row`, `col`
;; * `cols`, `rows`
;; :::

;; *   **`entry`**: Retrieves the element at a specific `[row col]` index.
;; *   **`row`**: Extracts a specified row as a vector.
;; *   **`col`**: Extracts a specified column as a vector.
;; *   **`rows`**: Returns sequence of rows
;; *   **`cols`**: Returns sequence of columns

(utls/examples-note
  (mat/entry M3x3 0 2)
  (mat/row M4x4 2)
  (mat/col RealMat 1)
  (mat/rows M2x2)
  (mat/cols RealMat))

;; #### Size and Shape

;; `nrow`, `ncol`, and `shape` provide the dimensions of the matrix.

;; ::: {.callout-tip title="Defined functions"}
;; * `nrow`, `ncol`, `shape`
;; :::

;; *   **`nrow`**: Returns the number of rows in the matrix.
;; *   **`ncol`**: Returns the number of columns in the matrix.
;; *   **`shape`**: Returns a vector or list containing the number of rows and columns, respectively, as a `[rows, cols]` pair.

(utls/examples-note
  (mat/nrow M2x2)
  (mat/ncol M3x3)
  (mat/shape M2x2)
  (mat/shape M3x3)
  (mat/shape M4x4)
  (mat/shape RealMat))

;; #### Properties

;; ::: {.callout-tip title="Defined functions"}
;; * `symmetric?`
;; * `diag`
;; * `det`
;; * `singular?`
;; * `trace`
;; :::

;; *   **Symmetry**:
;;     *   `symmetric?`: Checks if the matrix `A` is symmetric, meaning $A = A^T$. For a square matrix $A$, this holds if $a_{ij} = a_{ji}$ for all indices $i, j$. Can optionally take a tolerance parameter for approximate symmetry checks with floating-point numbers.
;; *   **Diagonal**:
;;     *   `diag`: Returns the main diagonal elements of a square matrix as a vector. For a matrix $A$, the diagonal vector is $[a_{11}, a_{22}, \dots, a_{nn}]$.
;; *   **Determinant**:
;;     *   `det`: Computes the determinant of a square matrix $A$, denoted as $|A|$ or $\det(A)$. The determinant is a scalar value that provides information about the matrix's properties, such as invertibility.
;; *   **Singularity**:
;;     *   `singular?`: Checks if a square matrix $A$ is singular (non-invertible). A matrix is singular if and only if its determinant is zero, i.e., $\det(A) = 0$.
;; *   **Trace**:
;;     *   `trace`: Computes the trace of a square matrix $A$, which is the sum of the elements on the main diagonal: $\operatorname{tr}(A) = \sum_{i=1}^n a_{ii}$. The trace is invariant under cyclic permutations and similarity transformations.

(utls/examples-note
  (mat/symmetric? M2x2)
  (mat/symmetric? (mat/eye 2))
  (mat/symmetric? (mat/mat2x2 1 0.1 0.001 1))
  (mat/symmetric? (mat/mat2x2 1 0.1 0.001 1) 0.1)
  (mat/diag M2x2)
  (mat/diag M3x3)
  (mat/diag M4x4)
  (mat/trace M2x2)
  (mat/trace M3x3)
  (mat/trace M4x4)
  (mat/det M2x2)
  (mat/det M3x3)
  (mat/det M4x4)
  (mat/singular? M2x2)
  (mat/singular? M3x3)
  (mat/singular? M4x4))

;; ### Matrix Arithmetic and Operations

;; Standard matrix addition, subtraction, and multiplication, as well as element-wise operations.

;; #### Basic Arithmetic

;; Functions for basic matrix arithmetic operations like addition and subtraction, including scalar operations.

;; ::: {.callout-tip title="Defined functions"}
;; * `add`, `adds`
;; * `sub`, `negate`
;; :::

;; *   **Addition**:
;;     *   `add`: Computes the sum of two matrices $\mathbf{C} = \mathbf{A} + \mathbf{B}$. This is an element-wise operation where $c_{ij} = a_{ij} + b_{ij}$. Both matrices must have the same dimensions. The function also handles summing a collection of matrices: $\sum \mathbf{A}_k$.
;;     *   `adds`: Adds a scalar value $s$ to each element of a matrix $\mathbf{A}$. $\mathbf{C} = \mathbf{A} + s$, where $c_{ij} = a_{ij} + s$.
;; *   **Subtraction**:
;;     *   `sub`: Computes the difference between two matrices $\mathbf{C} = \mathbf{A} - \mathbf{B}$, where $c_{ij} = a_{ij} - b_{ij}$. Both matrices must have the same dimensions. When called with a single matrix `A`, it performs negation.
;;     *   `negate`: Computes the negation of a matrix $\mathbf{C} = -\mathbf{A}$, where $c_{ij} = -a_{ij}$. This is equivalent to `sub` with one argument.
;;
;; For addition and subtraction of two matrices, they must have the same number of rows and columns.

;; :::: {.grid}

;; ::: {.g-col-6}
;; **Addition**
(mat/add M2x2 M2x2)
;; :::
;; ::: {.g-col-6}
;; **Subtraction**
(mat/sub M2x2 (mat/eye 2))
;; :::
;; ::: {.g-col-6}
;; **Scalar addition**
(mat/adds M2x2 100)
;; :::
;; ::: {.g-col-6}
;; **Negation**
(mat/negate M2x2)
;; :::

;; ::::

;; #### Matrix Multiplication

;; This section covers functions for performing matrix multiplication and related products, including standard matrix-matrix multiplication, element-wise products, and matrix-vector multiplication. These operations are fundamental in linear algebra and are used extensively in transformations, solving linear systems, and many data science tasks.
;;
;; ::: {.callout-tip title="Defined functions"}
;; * `mulm`, `mulmt`, `tmulm`, `tmulmt`
;; * `emulm`
;; * `muls`
;; * `mulv`, `vtmul`
;; * `outer`, `kronecker`
;; :::
;;
;; *   **Standard Matrix Multiplication**:
;;     *   `mulm`: Computes the matrix product $\mathbf{C} = \mathbf{A} \mathbf{B}$. The number of columns in $\mathbf{A}$ must equal the number of rows in $\mathbf{B}$. Can optionally perform multiplication involving transposed matrices: $\mathbf{A}^T \mathbf{B}$, $\mathbf{A} \mathbf{B}^T$, or $\mathbf{A}^T \mathbf{B}^T$.
;;     *   `mulmt`: Computes the matrix product $\mathbf{C} = \mathbf{A} \mathbf{B}^T$.
;;     *   `tmulm`: Computes the matrix product $\mathbf{C} = \mathbf{A}^T \mathbf{B}$.
;;     *   `tmulmt`: Computes the matrix product $\mathbf{C} = \mathbf{A}^T \mathbf{B}^T$.
;; *   **Element-wise and Scalar Multiplication**:
;;     *   `emulm`: Computes the element-wise product (Hadamard product) $\mathbf{C} = \mathbf{A} \odot \mathbf{B}$, where $c_{ij} = a_{ij} \cdot b_{ij}$. Requires input matrices to have the same dimensions.
;;     *   `muls`: Multiplies every element of matrix $\mathbf{A}$ by a scalar $s$: $\mathbf{C} = s \mathbf{A}$, where $c_{ij} = s \cdot a_{ij}$. This is also covered in basic operations but is relevant here.
;; *   **Matrix-Vector Multiplication**:
;;     *   `mulv`: Multiplies a matrix $\mathbf{A}$ by a column vector $\mathbf{v}$: $\mathbf{x} = \mathbf{A} \mathbf{v}$. The number of columns in $\mathbf{A}$ must equal the dimension of $\mathbf{v}$. Returns a vector.
;;     *   `vtmul`: Multiplies a row vector $\mathbf{v}^T$ by a matrix $\mathbf{A}$: $\mathbf{x}^T = \mathbf{v}^T \mathbf{A}$. The dimension of $\mathbf{v}$ must equal the number of rows in $\mathbf{A}$. Returns a vector.
;; *   **Special Products**:
;;     *   `outer`: Computes the outer product of two vectors $\mathbf{u}$ and $\mathbf{v}$. Returns a matrix $\mathbf{M} = \mathbf{u} \mathbf{v}^T$, where $m_{ij} = u_i v_j$.
;;     *   `kronecker`: Computes the Kronecker product of two matrices $\mathbf{A}$ and $\mathbf{B}$, denoted $\mathbf{A} \otimes \mathbf{B}$. If $\mathbf{A}$ is $m \times n$ and $\mathbf{B}$ is $p \times q$, the result is an $mp \times nq$ block matrix:
;;       $$
;;       \mathbf{A} \otimes \mathbf{B} = \begin{bmatrix}
;;       a_{11}\mathbf{B} & \dots & a_{1n}\mathbf{B} \\
;;       \vdots & \ddots & \vdots \\
;;       a_{m1}\mathbf{B} & \dots & a_{mn}\mathbf{B}
;;       \end{bmatrix}
;;       $$

;; ---

;; :::: {.grid}

;; ::: {.g-col-6}
;; $\mathbf{C} = \mathbf{A} \mathbf{B}$
(mat/mulm M2x2 M2x2)
(mat/mulm M2x2 false M2x2 false)
;; :::
;; ::: {.g-col-6}
;; $\mathbf{C} = \mathbf{A} \mathbf{B}^T$
(mat/mulmt M2x2 M2x2)
(mat/mulm M2x2 false M2x2 true)
;; :::
;; ::: {.g-col-6}
;; $\mathbf{C} = \mathbf{A}^T \mathbf{B}$
(mat/tmulm M2x2 M2x2)
(mat/mulm M2x2 true M2x2 false)
;; :::
;; ::: {.g-col-6}
;; $\mathbf{C} = \mathbf{A}^T \mathbf{B}^T$
(mat/tmulmt M2x2 M2x2)
(mat/mulm M2x2 true M2x2 true)
;; :::

;; ::::

;; ---

;; :::: {.grid}

;; ::: {.g-col-6}
;; **Element-wise multiplication**
(mat/emulm M3x3 M3x3)
;; :::

;; ::: {.g-col-6}
;; **Outer product**
(mat/outer (v/vec2 1 2) (v/vec2 3 4))
;; :::

;; ::: {.g-col-6}
;; **Scalar multiplication**
(mat/muls M3x3 0.5)
;; :::

;; ::: {.g-col-6}
(mat/outer (v/vec4 -1 1 2 3) (v/vec4 3 4 -2 -2))
;; :::


;; ::::

(utls/examples-note
  (mat/mulv M2x2 (v/vec2 10 20))
  (mat/mulv RealMat (v/vec->RealVector (v/vec3 1 2 3)))
  (mat/vtmul M2x2 (v/vec2 10 20))
  (mat/vtmul RealMat (v/vec->RealVector [1 2]))
  (mat/outer (v/vec2 1 2) [1 2 3 9])
  (mat/outer [2 3] [9 1 2])
  (mat/kronecker M2x2 M3x3)
  (mat/kronecker RealMat M2x2))

;; #### Element-wise Operations

;; A wide range of element-wise mathematical functions (e.g., `sin`, `cos`, `pow`) are provided, mirroring those in `fastmath.vector`.

;; `fmap` applies a function to each element of the vector, returning a new vector of the same type.

;; ::: {.callout-tip title="Defined functions"}
;; * `sin`, `cos`, `tan`, `asin`, `acos`, `atan`
;; * `sinh`, `cosh`, `tanh`, `asinh`, `acosh`, `atanh`
;; * `cot`, `sec`, `csc`, `acot`, `asec`, `acsc`
;; * `coth`, `sech`, `csch`, `acoth`, `asech`, `acsch`
;; * `sq`, `cb`, `safe-sqrt`, `sqrt`, `cbrt`, `pow`
;; * `exp`, `log`, `log10`, `log2`, `ln`, `log1p`, `expm1`
;; * `log1pexp`, `log1mexp`, `log1psq`, `log1pmx`, `logmxp1`, `logexpm1`
;; * `radians`, `degrees`, `sinc`, `sigmoid`, `logit`, `xlogx`
;; * `floor`, `ceil`, `round`, `rint`, `trunc`, `frac`, `sfrac`, `signum`, `sgn`
;; * `fmap`
;; :::

(mat/sin M4x4)
(mat/pow M2x2 0.5)

(mat/fmap M2x2 m/inc)

;; #### Rows and Columns Operations

;; Functions for transforming matrices, often used in data analysis or preparation, including normalization, centering, and scaling along rows or columns.

;; ::: {.callout-tip title="Defined functions"}
;; * `map-cols`, `map-rows`
;; * `shift-rows`, `shift-cols`
;; * `scale-rows`, `scale-cols`
;; * `normalize`, `demean`, `standardize`
;; :::

;; These functions provide tools to apply transformations to the rows or columns of a matrix. This is particularly useful for data preprocessing steps such as scaling features, centering data, or applying custom functions to individual dimensions (columns) or samples (rows) of a dataset represented as a matrix. The transformations can be applied element-wise, or based on properties of the rows/columns themselves (like mean or standard deviation).

;; *   **Row/Column Mapping**:
;;     *   `map-cols`: Applies a function `f` to each column vector of the matrix. The function `f` should take a vector as input and return a vector of the same dimension. The resulting vectors are assembled into a new matrix where each column is the result of applying `f` to the original columns.
;;     *   `map-rows`: Similar to `map-cols`, but applies the function `f` to each row vector of the matrix. The function `f` takes a row vector and should return a vector of the same dimension. The results are assembled into a new matrix where each row is the result of applying `f` to the original rows.

(mat/map-rows (fn [row] (conj (map (fn [[a b]] (- b a)) (partition 2 1 row)) (first row))) M3x3)
(mat/map-cols (fn [col] (v/shift col (- (stats/median col)))) M3x3)

;; *   **Shifting**:
;;     *   `shift-rows`: Adds a value to each element of each row. The value can be a single number applied to all rows, or the result of a function applied to each row vector (e.g., subtracting the mean of the row). Default function subtracts the mean of each row. For a row $\mathbf{r}$, the transformation is $\mathbf{r}' = \mathbf{r} + s$, where $s$ is the shift value for that row.
;;     *   `shift-cols`: Adds a value to each element of each column. The value can be a single number applied to all columns, or the result of a function applied to each column vector (e.g., subtracting the mean of the column). Default function subtracts the mean of each column. For a column $\mathbf{c}$, the transformation is $\mathbf{c}' = \mathbf{c} + s$.

(mat/shift-rows M3x3)
(mat/shift-rows M3x3 100)
(mat/shift-cols RealMat (comp m/- v/sum))

;; *   **Scaling**:
;;     *   `scale-rows`: Multiplies each element of each row by a value. The value can be a single number applied to all rows, or the result of a function applied to each row vector (e.g., dividing by the standard deviation of the row). For a row $\mathbf{r}$, the transformation is $\mathbf{r}' = s \cdot \mathbf{r}$, where $s$ is the scale value for that row.
;;     *   `scale-cols`: Multiplies each element of each column by a value. The value can be a single number applied to all columns, or the result of a function applied to each column vector.

;; Default function is the root mean square function $\frac{(n-1)}{\sqrt{(\mathbf{v}\cdot\mathbf{v})}}$

(v/dot (mat/col (mat/scale-cols M4x4) 1) (mat/col (mat/scale-cols M4x4) 1))
(mat/scale-rows M2x2 0.5)
(mat/scale-cols RealMat (comp m/sqrt v/sum))

;; *   **Statistical Transformations**: These functions apply common statistical preprocessing steps to rows or columns. By default, they operate on columns, which is a common convention in data science where columns represent features. An optional `rows?` argument (default `false`) allows applying the transformation to rows instead.
;;     *   `normalize`: Scales each row (if `rows?` is true) or column (if `rows?` is false) vector to have unit Euclidean length (magnitude 1). $\hat{\mathbf{v}} = \mathbf{v} / \Vert \mathbf{v} \Vert$.
;;     *   `demean`: Centers each row (if `rows?` is true) or column (if `rows?` is false) vector by subtracting its mean. $\mathbf{v}' = \mathbf{v} - \text{mean}(\mathbf{v})$.
;;     *   `standardize`: Centers and scales each row (if `rows?` is true) or column (if `rows?` is false) vector to have a mean of 0 and a standard deviation of 1. $\mathbf{v}' = (\mathbf{v} - \text{mean}(\mathbf{v})) / \text{stddev}(\mathbf{v})$. This is also known as Z-score normalization.

;; :::: {.grid}

;; ::: {.g-col-4}
(mat/normalize M3x3) 
(mat/normalize M3x3 true)
;; :::
;; ::: {.g-col-4}
(mat/demean M3x3)
(mat/demean M3x3 true)
;; :::
;; ::: {.g-col-4}
(mat/standardize M3x3)
(mat/standardize M3x3 true)
;; :::
;; ::::

;; ### Geometric Transformations

;; Functions specifically for creating transformation matrices, primarily rotations in 2D and 3D space. These matrices are used to transform points or vectors by applying matrix multiplication.

;; #### 2D Rotation

;; Functions for creating rotation matrices in 2D space, typically used to rotate points or vectors around the origin.
;;
;; ::: {.callout-tip title="Defined functions"}
;; * `rotation-matrix-2d`
;; :::
;;
;; *   `rotation-matrix-2d`: Creates a 2x2 rotation matrix for a given angle $\theta$ (in radians).
;;     The matrix is defined as:
;;     $$
;;     R(\theta) = \begin{bmatrix}
;;     \cos \theta & -\sin \theta \\
;;     \sin \theta & \cos \theta
;;     \end{bmatrix}
;;     $$
;;     Multiplying a 2D vector $\mathbf{v} = [x, y]^T$ by this matrix rotates the vector by $\theta$ counterclockwise: $\mathbf{v}' = R(\theta) \mathbf{v}$.
;;

(mat/rotation-matrix-2d m/HALF_PI)

;; Rotate [1, 0] by pi/2
(mat/mulv (mat/rotation-matrix-2d m/HALF_PI) (v/vec2 1 0)) 

(mat/rotation-matrix-2d m/PI)

;; #### 3D Rotations

;; `rotation-matrix-3d` creates a 3x3 rotation matrix from Euler angles (Tait–Bryan z-y′-x″ convention). `rotation-matrix-3d-x`, `-y`, and `-z` create simple rotations around the respective axes. `rotation-matrix-axis-3d` creates a 3x3 rotation matrix for rotation around an arbitrary axis.

;; ::: {.callout-tip title="Defined functions"}
;; * `rotation-matrix-3d`, `rotation-matrix-3d-x`, `rotation-matrix-3d-y`, `rotation-matrix-3d-z`
;; * `rotation-matrix-axis-3d`
;; :::
;;
;; These functions generate 3x3 matrices used to rotate 3D points or vectors.
;;
;; *   **Axis Rotations**:
;;     *   `rotation-matrix-3d-x`: Creates a 3x3 matrix for rotation by angle $\theta$ around the x-axis (right-hand rule).
;;       $$
;;       R_x(\theta) = \begin{bmatrix}
;;       1 & 0 & 0 \\
;;       0 & \cos\theta & -\sin\theta \\
;;       0 & \sin\theta & \cos\theta
;;       \end{bmatrix}
;;       $$
;;     *   `rotation-matrix-3d-y`: Creates a 3x3 matrix for rotation by angle $\theta$ around the y-axis (right-hand rule).
;;       $$
;;       R_y(\theta) = \begin{bmatrix}
;;       \cos\theta & 0 & \sin\theta \\
;;       0 & 1 & 0 \\
;;       -\sin\theta & 0 & \cos\theta
;;       \end{bmatrix}
;;       $$
;;     *   `rotation-matrix-3d-z`: Creates a 3x3 matrix for rotation by angle $\theta$ around the z-axis (right-hand rule).
;;       $$
;;       R_z(\theta) = \begin{bmatrix}
;;       \cos\theta & -\sin\theta & 0 \\
;;       \sin\theta & \cos\theta & 0 \\
;;       0 & 0 & 1
;;       \end{bmatrix}
;;       $$


(mat/rotation-matrix-3d-x m/HALF_PI)
(mat/rotation-matrix-3d-y m/HALF_PI)
(mat/rotation-matrix-3d-z m/HALF_PI)

(kind/plotly
 (let [v (v/vec3 1 1.5 -2)
       r1 (mat/rotation-matrix-3d-x (m// m/PI 15))
       v1 (take 30 (iterate (partial mat/mulv r1) v))
       r1 (mat/rotation-matrix-3d-y (m// m/PI 15))
       v2 (take 30 (iterate (partial mat/mulv r1) v))
       r1 (mat/rotation-matrix-3d-z (m// m/PI 15))
       v3 (take 30 (iterate (partial mat/mulv r1) v))]
   {:data [(plt/scatter3d-data v1 "X-axis rotation" plt/c1)
           (plt/scatter3d-data v2 "Y-axis rotation" plt/c2)
           (plt/scatter3d-data v3 "Z-axis rotation" plt/c3)
           (plt/line3d-data [[0 0 0] v] "rotated vector")
           (plt/line3d-data [[0 0 0] [1 0 0]] "X-axis" gg/color-light)
           (plt/line3d-data [[0 0 0] [0 1 0]] "Y-axis" gg/color-light)
           (plt/line3d-data [[0 0 0] [0 0 1]] "Z-axis" gg/color-light)]
    :layout {:title "Rotation of [1, 1.5, -2] vector, 12 degrees."}}))

;; *   **Euler Angles**:
;;     *   `rotation-matrix-3d`: Creates a 3x3 rotation matrix from sequential rotations specified by Euler angles (specifically, the Tait–Bryan angles z-y′-x″ convention). Given angles $\gamma, \beta, \alpha$ for rotations around the Z, Y', X'' axes respectively. The function accepts `alpha` (x),  `beta` (y) and `gamma` (z).

;; $$R = R_{x''}(\alpha) R_{y'}(\beta) R_z(\gamma) = \begin{bmatrix}
;; c_\beta c_\gamma                              & - c_\beta s_\gamma                            & s_\beta \\
;; c_\alpha s_\gamma + c_\gamma s_\alpha s_\beta & c_\alpha c_\gamma - s_\alpha s_\beta s_\gamma & - c_\beta s_\alpha \\
;; s_\alpha s_\gamma - c_\alpha c_\gamma s_\beta & c_\gamma s_\alpha + c_\alpha s_\beta s_\gamma & c_\alpha c_\beta
;; \end{bmatrix}$$

(mat/rotation-matrix-3d m/HALF_PI m/QUARTER_PI 0)

(kind/plotly
 (let [v (v/vec3 1 1.5 -2)
       r1 (mat/rotation-matrix-3d (m// m/PI 15) (m// m/PI 5) (m// m/PI 10))
       v1 (take 20 (iterate (partial mat/mulv r1) v))]
   {:data [(plt/scatter3d-data v1 "Rotation" plt/c1)
           (plt/line3d-data [(v/vec3 0 0 0) v] "rotated vector")
           (plt/line3d-data [[0 0 0] [1 0 0]] "X-axis" gg/color-light)
           (plt/line3d-data [[0 0 0] [0 1 0]] "Y-axis" gg/color-light)
           (plt/line3d-data [[0 0 0] [0 0 1]] "Z-axis" gg/color-light)]
    :layout {:title "Rotation of [1, 1.5, -2] vector, α=12, β=36, γ=18 degrees."}}))

;; *   **Arbitrary Axis Rotation**:
;;     *   `rotation-matrix-axis-3d`: Creates a 3x3 rotation matrix for rotating by angle $\theta$ around a specified arbitrary axis $\mathbf{k}$. If $\mathbf{k}$ is a unit vector, the rotation matrix can be constructed using Rodrigues' rotation formula or its matrix equivalent.
;;       $$
;;       R = I + (\sin\theta) K + (1-\cos\theta) K^2
;;       $$
;;       where $I$ is the identity matrix and $K$ is the skew-symmetric matrix of $\mathbf{k}$:
;;       $$
;;       K = \begin{bmatrix}
;;       0 & -k_z & k_y \\
;;       k_z & 0 & -k_x \\
;;       -k_y & k_x & 0
;;       \end{bmatrix}
;;       $$
;;       The function can also take an optional pivot point `p` to represent rotation around a point other than the origin. The transformation of a point $\mathbf{v}$ around `p` by angle $\theta$ and axis $\mathbf{k}$ is $R(\mathbf{v} - \mathbf{p}) + \mathbf{p}$.

(mat/rotation-matrix-axis-3d m/HALF_PI (v/vec3 1 1 1))

(kind/plotly
 (let [v (v/vec3 1 1.5 -2)
       a (v/vec3 1 1 1)
       r1 (mat/rotation-matrix-axis-3d (m// m/PI 15) a)
       v1 (take 30 (iterate (partial mat/mulv r1) v))]
   {:data [(plt/scatter3d-data v1 "X-axis rotation" plt/c1)
           (plt/line3d-data [(v/vec3 0 0 0) v] "rotated vector")
           (plt/line3d-data [(v/vec3 0 0 0) a] "rotation axis" gg/color-light)]
    :layout {:title "Rotation of [1, 1.5, -2] vector around [1, 1, 1] axis, 12 degrees."}}))


;; Rotating point [1 0 0] around [0 0 0] by 90 deg around Z axis

(mat/mulv (mat/rotation-matrix-axis-3d m/HALF_PI (v/vec3 0 0 1)) (v/vec3 1 0 0))

;; ### Matrix Decompositions

;; Matrix decomposition (or factorization) is a technique that breaks down a matrix into a product of other matrices with specific properties. These decompositions simplify complex matrix operations, reveal important characteristics of the matrix (like rank, eigenvalues, stability), and are crucial for solving linear systems, computing inverses, and performing various numerical computations more efficiently and stably. `fastmath.matrix` leverages Apache Commons Math to provide implementations of several common decompositions.
;;
;; ::: {.callout-tip title="Defined functions"}
;; * `qr-decomposition`
;; * `rrqr-decomposition`
;; * `cholesky-decomposition`
;; * `sv-decomposition`
;; * `lu-decomposition`
;; * `eigen-decomposition`
;; * `decomposition-component`
;; * `singular?`
;; * `inverse`
;; * `solve`
;; :::

;; Each decomposition function takes a matrix as input and returns a special object (`MatrixDecomposition` record). This object encapsulates the results of the decomposition and provides a more efficient way to perform subsequent operations that utilize the decomposition (like solving linear systems or finding the inverse) compared to performing these operations directly on the original matrix or calculating the components explicitly.

;; *   **Accessing Components**:
;;     *   `decomposition-component`: Extracts specific matrices (like $\mathbf{Q}, \mathbf{R}, \mathbf{L}, \mathbf{U}, \mathbf{V}, \mathbf{D}, \mathbf{S}, \mathbf{P}, \mathbf{H}, \mathbf{V}^T=\mathbf{VT}, \mathbf{U}^T=\mathbf{UT}, \mathbf{L}^T=\mathbf{LT}$, $\mathbf{D}^{1/2}=\mathbf{sqrt}$) or other results (like `:pivot` vector, `:singular-values` vector, `:det` determinant, `:real-eigenvalues` / `:imag-eigenvalues` vectors, `:complex?` boolean, `:info` map, `:rank-fn` function, `:covariance-fn` function) from a decomposition object. Components are lazy where possible.
;;
;; *   **Using Decomposition Results**: The decomposition objects themselves implement the `fastmath.protocols/MatrixProto`. This means you can directly call `solve`, `inverse`, and `singular?` on the decomposition result:
;;     *   `solve`: Solves the linear system $\mathbf{A} \mathbf{x} = \mathbf{b}$ using the pre-computed decomposition. This is generally faster and more numerically stable than solving the system directly using the original matrix, especially for large systems or matrices with poor condition numbers.
;;     *   `inverse`: Computes the inverse matrix $\mathbf{A}^{-1}$ from the decomposition. Similar to `solve`, using the decomposition is typically more efficient. Returns `nil` if the matrix is singular.
;;     *   `singular?`: Checks if the matrix is singular based on the decomposition (e.g., checking the determinant for LU/Eigen or pivots/singular values for others).


;; ####  QR

;; Computes the QR decomposition $\mathbf{A} = \mathbf{Q} \mathbf{R}$, where $\mathbf{Q}$ is an orthogonal matrix ($\mathbf{Q}^T \mathbf{Q} = \mathbf{I}$) and $\mathbf{R}$ is an upper triangular matrix. Useful for solving linear least squares problems and eigenvalue computations.

(def QR (mat/qr-decomposition M3x3))

(mat/decomposition-component QR :Q)
(mat/decomposition-component QR :R)
(mat/decomposition-component QR :QT)
(mat/decomposition-component QR :H)

(mat/singular? QR)
(mat/inverse QR)
(mat/solve QR V3)

;; #### RRQR

;; Computes the Rank-Revealing QR decomposition $\mathbf{A} = \mathbf{Q} \mathbf{R} \mathbf{P}^T$, similar to QR but with a permutation matrix $\mathbf{P}$ that helps determine the numerical rank. Useful for rank determination and handling rank-deficient matrices.

(def RRQR (mat/rrqr-decomposition M3x3))

(mat/decomposition-component RRQR :Q)
(mat/decomposition-component RRQR :R)
(mat/decomposition-component RRQR :QT)
(mat/decomposition-component RRQR :H)
(mat/decomposition-component RRQR :P)

(def rrqr-rank (mat/decomposition-component RRQR :rank-fn))

(rrqr-rank 0)

(mat/singular? RRQR)
(mat/inverse RRQR)
(mat/solve RRQR V3)

;; #### Cholesky

;; Computes the Cholesky decomposition $\mathbf{A} = \mathbf{L} \mathbf{L}^T$ (or $\mathbf{A} = \mathbf{U}^T \mathbf{U}$), applicable to symmetric positive-definite matrices. $\mathbf{L}$ is a lower triangular matrix. Efficient for solving symmetric linear systems.

(def Cholesky (mat/cholesky-decomposition (mat/mulmt M3x3 M3x3)))

(mat/decomposition-component Cholesky :L)
(mat/decomposition-component Cholesky :LT)
(mat/decomposition-component Cholesky :det)

(mat/singular? Cholesky)
(mat/inverse Cholesky)
(mat/solve Cholesky V3)

;; #### SVD

;; Computes the Singular Value Decomposition (SVD) $\mathbf{A} = \mathbf{U} \mathbf{S} \mathbf{V}^T$, where $\mathbf{U}$ and $\mathbf{V}$ are orthogonal matrices and $\mathbf{S}$ is a diagonal matrix containing the singular values. The SVD is one of the most powerful decompositions, providing insights into matrix rank, approximation, and used in dimensionality reduction (like PCA).

(def SVD (mat/sv-decomposition M3x3))

(mat/decomposition-component SVD :S)
(mat/decomposition-component SVD :U)
(mat/decomposition-component SVD :UT)
(mat/decomposition-component SVD :V)
(mat/decomposition-component SVD :VT)

(mat/decomposition-component SVD :singular-values)
(utls/zp (mat/decomposition-component SVD :info))

(def svd-covariance (mat/decomposition-component SVD :covariance-fn))

(svd-covariance)

(mat/singular? SVD)
(mat/inverse SVD)
(mat/solve SVD V3)

;; #### LU

;; Computes the LU decomposition with partial pivoting $\mathbf{P} \mathbf{A} = \mathbf{L} \mathbf{U}$ (equivalent to $\mathbf{A} = \mathbf{P}^{-1} \mathbf{L} \mathbf{U}$), where $\mathbf{P}$ is a permutation matrix, $\mathbf{L}$ is a lower triangular matrix with unit diagonal, and $\mathbf{U}$ is an upper triangular matrix. Used for solving square linear systems and computing determinants and inverses.

(def LU (mat/lu-decomposition M3x3))

(mat/decomposition-component LU :L)
(mat/decomposition-component LU :U)
(mat/decomposition-component LU :P)
(mat/decomposition-component LU :pivot)
(mat/decomposition-component LU :det)

(mat/singular? LU)
(mat/inverse LU)
(mat/solve LU V3)

;; #### Eigen

;; Computes the Eigen decomposition $\mathbf{A} = \mathbf{V} \mathbf{D} \mathbf{V}^{-1}$, where $\mathbf{D}$ is a diagonal or block diagonal matrix containing the eigenvalues, and $\mathbf{V}$ is a matrix whose columns are the corresponding eigenvectors. Applies to square matrices (real or complex eigenvalues/vectors). Reveals how a linear transformation stretches or compresses space. `:sqrt` component is computed only for symmetric and positive definite matrices.

(def Eigen (mat/eigen-decomposition (mat/mulmt M3x3 M3x3)))

(mat/decomposition-component Eigen :V)
(mat/decomposition-component Eigen :D)
(mat/decomposition-component Eigen :VT)
(mat/decomposition-component Eigen :sqrt)
(mat/decomposition-component Eigen :det)

(mat/decomposition-component Eigen :complex?)
(mat/decomposition-component Eigen :real-eigenvalues)
(mat/decomposition-component Eigen :imag-eigenvalues)
(mat/decomposition-component Eigen :eigenvectors)

(mat/singular? Eigen)
(mat/inverse Eigen)
(mat/solve Eigen V3)

;; ### Solving Linear Systems

;; This section covers functions for solving linear systems ($\mathbf{A} \mathbf{x} = \mathbf{b}$) and computing matrix inverses ($\mathbf{A}^{-1}$), which are fundamental operations in linear algebra. A matrix is invertible if and only if it is not singular (i.e., its determinant is non-zero). `fastmath.matrix` provides functions to check for singularity and compute the inverse, leveraging the underlying matrix types and decomposition results for efficiency and numerical stability.

;; ::: {.callout-tip title="Defined functions"}
;; * `solve`
;; * `inverse`
;; * `singular?`
;; :::

;; *   **`solve`**: Solves the linear system $\mathbf{A} \mathbf{x} = \mathbf{b}$ for the unknown vector $\mathbf{x}$. It can be called with the matrix $\mathbf{A}$ and the right-hand side vector $\mathbf{b}$ directly. For better performance and numerical stability, especially with large or ill-conditioned matrices, it is recommended to first compute a matrix decomposition of $\mathbf{A}$ and then call `solve` on the resulting decomposition object. Returns the solution vector $\mathbf{x}$.

;; `QR`, `RRQR`, `Cholesky` and `SVD` decompositions solve in a least squares sense by finding $\hat{\boldsymbol{x}} = \underset{\boldsymbol{x}}{\operatorname{arg\,min}}\left\|\mathbf b - \mathbf{A} \boldsymbol x \right\|^2$

(utls/examples-note
  (mat/solve M2x2 (v/vec2 1 1))
  (mat/solve M3x3 V3)
  (-> (mat/lu-decomposition M2x2) (mat/solve (v/vec2 1 1)))
  (-> (mat/sv-decomposition M3x3) (mat/solve V3))
  (mat/singular? M4x4)
  (-> (mat/qr-decomposition M4x4) (mat/solve V4)))

;; *   **`inverse`**: Computes the inverse matrix $\mathbf{A}^{-1}$ such that $\mathbf{A} \mathbf{A}^{-1} = \mathbf{A}^{-1} \mathbf{A} = \mathbf{I}$, where $\mathbf{I}$ is the identity matrix. Like `solve`, it can be called directly on a matrix $\mathbf{A}$, but is more efficient when called on a pre-computed matrix decomposition object.

;; When used on directly on a matrix $\mathbf{A}$, returns the inverse matrix $\mathbf{A}^{-1}$, or `nil` if the matrix is singular.

;; When used on decomposition, finds a pseudoinverse $\mathbf{A^{+}}$.

(mat/inverse M2x2)
(mat/inverse M3x3)
(mat/inverse M4x4)

;; Pseudoinverse

(mat/inverse (mat/sv-decomposition M4x4))

;; $\mathbf{A}\mathbf{A^{+}}\mathbf{A}=\mathbf{A}$

(-> M4x4
    (mat/mulm (mat/inverse (mat/sv-decomposition M4x4)))
    (mat/mulm M4x4))

;; *   **`singular?`**: Checks if a square matrix $\mathbf{A}$ is singular. A matrix is singular if its determinant is zero ($\det(\mathbf{A}) = 0$), which means it is not invertible and the linear system $\mathbf{A} \mathbf{x} = \mathbf{b}$ may have no unique solution. This function can be called directly on a matrix or on a matrix decomposition object. Returns `true` if the matrix is singular, `false` otherwise.

(utls/examples-note
  (mat/singular? M2x2)
  (mat/singular? M3x3)
  (mat/singular? M4x4)
  (mat/singular? (mat/sv-decomposition M4x4)))

;; ### Eigenvalues and Singular Values

;; This section provides functions to compute the eigenvalues and eigenvectors of square matrices and the singular values of arbitrary matrices. Eigenvalues and eigenvectors characterize how a linear transformation stretches or compresses space and the directions along which this occurs. Singular values generalize this concept to non-square matrices and are fundamental in dimensionality reduction, least squares problems, and matrix approximation. These functions rely on matrix decompositions, specifically the Eigen decomposition and Singular Value Decomposition (SVD).

;; See also [[Eigen]]

;;
;; ::: {.callout-tip title="Defined functions"}
;; * `eigenvalues`, `singular-values`, `eigenvalues-matrix`, `eigenvectors`
;; :::
;;
;; *   **`eigenvalues`**: Computes the eigenvalues of a square matrix $A$. Returns a sequence of 2D vectors (`Vec2`), where the `x` component is the real part of the eigenvalue and the `y` component is the imaginary part. If the matrix is real and symmetric, all imaginary parts will be zero.
;;
;; *   **`singular-values`**: Computes the singular values of an arbitrary matrix $A$. These are the non-negative square roots of the eigenvalues of the positive semi-definite matrix $A^T A$. Returns a sequence of non-negative double values, typically sorted in descending order.
;;
;; *   **`eigenvalues-matrix`**: Returns a matrix $\mathbf{D}$ from the Eigen decomposition $\mathbf{A} = \mathbf{V} \mathbf{D} \mathbf{V}^{-1}$, where $\mathbf{D}$ is a diagonal matrix containing the real eigenvalues on its main diagonal, or a block diagonal matrix for complex conjugate pairs of eigenvalues. Only applies to square matrices.
;;
;; *   **`eigenvectors`**: Computes the eigenvectors of a square matrix $A$. Returns a matrix $\mathbf{V}$ whose columns are the corresponding eigenvectors. If the matrix has complex eigenvalues, the corresponding eigenvectors will also be complex (represented by the columns of V from `EigenDecomposition` in ACM, which may not directly align with the real/imaginary pairs from `eigenvalues`). Can optionally normalize the eigenvectors.

(utls/examples-note
  (mat/eigenvalues M3x3)
  (mat/singular-values M3x3)
  (mat/singular-values RealMat))

(mat/eigenvalues-matrix M3x3)
(mat/eigenvectors M3x3)
(mat/eigenvectors M3x3 true)

;; ### Matrix Norms and Condition Number

;; Functions to compute various matrix norms and the condition number. Matrix norms measure the "size" or "magnitude" of a matrix, and the condition number quantifies how sensitive the solution of a linear system is to changes in the input data. These concepts are vital for analyzing the properties of matrices, assessing the numerical stability of algorithms (like solving linear systems or computing inverses), and understanding the behaviour of transformations represented by matrices.

;; ::: {.callout-tip title="Defined functions"}
;; * `norm`
;; * `condition`
;; :::

;; *   **`norm`**: Computes a specific matrix norm of `A`. The type of norm is specified by the `norm-type` argument. Supported types include:
;;     *   `1`: The L1 norm (maximum absolute column sum). $\Vert A \Vert_1 = \max_{j} \sum_{i=1}^m |a_{ij}|$.
;;     *   `:inf`: The L-infinity norm (maximum absolute row sum). $\Vert A \Vert_\infty = \max_{i} \sum_{j=1}^n |a_{ij}|$.
;;     *   `2`: The spectral norm (largest singular value). $\Vert A \Vert_2 = \sigma_{\max}(A)$.
;;     *   `:max`: The maximum absolute value norm. $\Vert A \Vert_{\max} = \max_{i,j} |a_{ij}|$.
;;     *   `:frobenius`: The Frobenius norm. $\Vert A \Vert_F = \sqrt{\sum_{i=1}^m \sum_{j=1}^n |a_{ij}|^2} = \sqrt{\operatorname{tr}(A^T A)}$. This is a special case of the generalized L$_{p,q}$ norm with $p=2, q=2$.
;;     *   `[p, q]`: The generalized L$_{p,q}$ norm. A specific implementation is provided for $[2,2]$ (Frobenius) and $[p,p]$ (entrywise p-norm).
;;     *   `[p]`: The Schatten p-norm, which is the L-p norm of the vector of singular values. $\Vert A \Vert_p = (\sum_{i=1}^{\min(m,n)} \sigma_i^p)^{1/p}$. Includes `:nuclear` or `:trace` norm for $p=1$.
;;
;;     If no `norm-type` is provided, it defaults to the L1 norm (`1`).
;;
;; *   **`condition`**: Computes the condition number of a matrix `A` with respect to a given norm `norm-type`. It is defined as $\operatorname{cond}(A) = \Vert A \Vert \Vert A^{-1} \Vert$. A large condition number indicates that the matrix is close to being singular, and linear systems involving the matrix may be ill-conditioned, meaning small changes in the input can lead to large changes in the output solution.
;;
;;     Defaults to the L2 norm (`2`) for calculation.

(utls/examples-note
  (mat/norm M2x2)
  (mat/norm M2x2 :inf)
  (mat/norm M2x2 2)
  (mat/norm M2x2 :frobenius)
  (mat/norm M2x2 :max)
  (mat/norm M2x2 [2 2])
  (mat/norm M2x2 [3 3])
  (mat/norm M2x2 [1])

  (mat/norm M4x4)
  (mat/norm M4x4 :inf)
  (mat/norm M4x4 2)
  (mat/norm M4x4 :frobenius)
  (mat/norm M4x4 :max)
  (mat/norm M4x4 [2 2])
  (mat/norm M4x4 [3 3])
  (mat/norm M4x4 [1])

  (mat/condition M2x2)
  (mat/condition M2x2 :inf)
  (mat/condition M2x2 1))

;; ## Reference

(codox/make-public-fns-table-clay 'fastmath.vector)
(codox/make-public-fns-table-clay 'fastmath.matrix)
