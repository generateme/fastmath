<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>fastmath.clustering documentation</title><script type="text/javascript" async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Fastmath</span> <span class="project-version">1.5.3</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1"><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fastmath</span></div></div></li><li class="depth-2 branch"><a href="fastmath.classification.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>classification</span></div></a></li><li class="depth-2 branch current"><a href="fastmath.clustering.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clustering</span></div></a></li><li class="depth-2 branch"><a href="fastmath.complex.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>complex</span></div></a></li><li class="depth-2 branch"><a href="fastmath.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="fastmath.distance.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>distance</span></div></a></li><li class="depth-2 branch"><a href="fastmath.easings.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>easings</span></div></a></li><li class="depth-2 branch"><a href="fastmath.fields.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fields</span></div></a></li><li class="depth-2 branch"><a href="fastmath.grid.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>grid</span></div></a></li><li class="depth-2 branch"><a href="fastmath.interpolation.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>interpolation</span></div></a></li><li class="depth-2 branch"><a href="fastmath.kernel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>kernel</span></div></a></li><li class="depth-2 branch"><a href="fastmath.optimization.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>optimization</span></div></a></li><li class="depth-2 branch"><a href="fastmath.protocols.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocols</span></div></a></li><li class="depth-2 branch"><a href="fastmath.random.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>random</span></div></a></li><li class="depth-2 branch"><a href="fastmath.regression.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>regression</span></div></a></li><li class="depth-2 branch"><a href="fastmath.signal.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>signal</span></div></a></li><li class="depth-2 branch"><a href="fastmath.stats.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>stats</span></div></a></li><li class="depth-2 branch"><a href="fastmath.transform.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>transform</span></div></a></li><li class="depth-2"><a href="fastmath.vector.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>vector</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="fastmath.clustering.html#var-clarans"><div class="inner"><span>clarans</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-clustering-methods-list"><div class="inner"><span>clustering-methods-list</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-dbscan"><div class="inner"><span>dbscan</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-denclue"><div class="inner"><span>denclue</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-deterministic-annealing"><div class="inner"><span>deterministic-annealing</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-g-means"><div class="inner"><span>g-means</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-k-means"><div class="inner"><span>k-means</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-mec"><div class="inner"><span>mec</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-neural-gas"><div class="inner"><span>neural-gas</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-outlier-id"><div class="inner"><span>outlier-id</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-predict"><div class="inner"><span>predict</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-regroup"><div class="inner"><span>regroup</span></div></a></li><li class="depth-1"><a href="fastmath.clustering.html#var-x-means"><div class="inner"><span>x-means</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">fastmath.clustering</h1><div class="doc"><div class="markdown"><p>Clustering algorithms.</p>
<p>Various clustering algrorithms backed by SMILE library.</p>
<p>Currently implemented: only partition clustering.</p>
<h3><a href="#input-data" name="input-data"></a>Input data</h3>
<p>Itâ€™s always sequence of n-sized samples as sequences.</p>
<p>For example, 2d samples <code>[[1 2] [2 2] [3 3] ...]</code></p>
<p>For 1d data you can pass sequence of numbers of sequence of 1d seqs of numbers</p>
<pre><code class="clojure">[1 2 3]
;; or
[[1] [2] [3]]
</code></pre>
<h3><a href="#distances" name="distances"></a>Distances</h3>
<p>Some of the methods use distance functions, use <a href="fastmath.distance.html">fastmath.distance</a> namespace to create one.</p>
<h3><a href="#output" name="output"></a>Output</h3>
<p>Every function returns record which contains:</p>
<ul>
  <li><code>:type</code> - name of the method used</li>
  <li><code>:data</code> - input data</li>
  <li><code>:clustering</code> - sequence of cluster ids</li>
  <li><code>:sizes</code> - sizes of clusters</li>
  <li><code>:clusters</code> - number of clusters</li>
  <li><code>:predict</code> - predicting function (see below), qualify additional sample</li>
  <li><code>:representatives</code> - list of centroids or medoids if available</li>
  <li><code>:info</code> - additional statistics for your samples (like distortion)</li>
  <li><code>:obj</code> - SMILE object</li>
</ul>
<p>Cluster id is a integer ranging from 0 to the number of clusters minus 1. Some methods mark outliers with <a href="fastmath.clustering.html#var-outlier-id">outlier-id</a>.</p>
<p>Record acts as function and can qualify additonal sample by calling <code>:predict</code> function (or just call <a href="fastmath.clustering.html#var-predict">predict</a>), for example (<code>data</code> is sequence of 3d samples):</p>
<pre><code class="clojure">(let [cl (k-means data 10)] (cl [0 1 2]))
</code></pre>
<p>See <a href="fastmath.clustering.html#var-k-means">k-means</a></p>
<h4><a href="#regrouping" name="regrouping"></a>Regrouping</h4>
<p>Clustering record can be regroupped to the list of individual clusters. Call <a href="fastmath.clustering.html#var-regroup">regroup</a> and get list of maps with following structure:</p>
<ul>
  <li><code>:key</code> - cluster id</li>
  <li><code>:data</code> - samples which belong to the cluster</li>
  <li><code>:outliers?</code> - does it contain outliers or not</li>
  <li><code>:representative</code> - centroid/medoid or average vector if the former is not available</li>
  <li><code>:size</code> - size of cluster</li>
</ul></div><div class="markdown"><h4>Categories</h4><ul></ul><p>Other vars: <a>-&gt;ClusteringResult</a> <a href="fastmath.clustering.html#var-clarans">clarans</a> <a href="fastmath.clustering.html#var-clustering-methods-list">clustering-methods-list</a> <a href="fastmath.clustering.html#var-dbscan">dbscan</a> <a href="fastmath.clustering.html#var-denclue">denclue</a> <a href="fastmath.clustering.html#var-deterministic-annealing">deterministic-annealing</a> <a href="fastmath.clustering.html#var-g-means">g-means</a> <a href="fastmath.clustering.html#var-k-means">k-means</a> <a>map-&gt;ClusteringResult</a> <a href="fastmath.clustering.html#var-mec">mec</a> <a href="fastmath.clustering.html#var-neural-gas">neural-gas</a> <a href="fastmath.clustering.html#var-predict">predict</a> <a href="fastmath.clustering.html#var-regroup">regroup</a> <a href="fastmath.clustering.html#var-x-means">x-means</a></p></div><div class="markdown"><h4>Constants</h4><ul><li><a href="fastmath.clustering.html#var-outlier-id">outlier-id</a> = <code>2147483647</code></li></ul></div></div><div class="public anchor" id="var-clarans"><h3>clarans</h3><div class="usage"><code>(clarans data clusters)</code><code>(clarans data dist clusters)</code><code>(clarans data dist clusters max-neighbor)</code><code>(clarans data dist clusters max-neighbor num-local)</code></div><div class="doc"><div class="markdown"><p>Clustering Large Applications based upon RANdomized Search algorithm.</p>
<p>Input:</p>
<ul>
  <li>data - sequence of samples</li>
  <li>clusters - numbe of clusters</li>
</ul>
<p>Optional:</p>
<ul>
  <li>dist - distance method, default <code>:euclidean</code></li>
  <li>max-neighbor - maximum number of neighbors checked during random search</li>
  <li>num-local - the number of local minima to search for</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/smile/api/java/smile/clustering/CLARANS.html">SMILE doc</a></p></div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Usage</p></blockquote><pre><code class="hljs clojure">(dissoc (clarans (repeatedly
                  1000
                  (fn* []
                    (r/randval 0.1 (r/irand -10 10) (r/irand 100 150))))
                 d/chebyshev
                 2)
        :data :clustering
        :obj :predict)
;;=&gt; {:clusters 2,
;;=&gt;  :info {:distortion 11609.0, :maxneighbor 100, :numlocalminima 4},
;;=&gt;  :representatives ((0.0) (124.0)),
;;=&gt;  :sizes (97 903),
;;=&gt;  :type :clarans}</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L207">view source</a></div></div><div class="public anchor" id="var-clustering-methods-list"><h3>clustering-methods-list</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>List of clustering methods.</p></div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>List of methods</p></blockquote><pre><code class="hljs clojure">clustering-methods-list
;;=&gt; (:dbscan :k-means :mec
;;=&gt;          :clarans :g-means
;;=&gt;          :neural-gas :x-means
;;=&gt;          :deterministic-annealing :denclue)</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L106">view source</a></div></div><div class="public anchor" id="var-dbscan"><h3>dbscan</h3><div class="usage"><code>(dbscan data min-pts radius)</code><code>(dbscan data dist min-pts radius)</code></div><div class="doc"><div class="markdown"><p>Density-Based Spatial Clustering of Applications with Noise algorithm.</p>
<p>Input:</p>
<ul>
  <li>data - sequence of samples</li>
  <li>dist (optional) - distance method, default <code>:euclidean</code></li>
  <li>min-pts - minimum number of neighbors</li>
  <li>radius - the neighborhood radius</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/smile/api/java/smile/clustering/DBSCAN.html">SMILE doc</a></p></div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>3d vectors</p></blockquote><pre><code class="hljs clojure">(dissoc (dbscan
         (repeatedly
          5000
          (fn* []
            (vector (r/randval 0.1 (r/irand -10 10) (r/irand 100 150))
                    (r/randval (r/irand -10 10) (r/irand 100 150))
                    (r/randval (r/irand -10 10) (r/irand 100 150)))))
         10
         20)
        :data :clustering
        :obj :predict)
;;=&gt; {:clusters 8,
;;=&gt;  :info {:minpts 10.0, :radius 20.0},
;;=&gt;  :representatives nil,
;;=&gt;  :sizes (1113 1123 1128 1103 152 133 120 128 0),
;;=&gt;  :type :dbscan}</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L227">view source</a></div></div><div class="public anchor" id="var-denclue"><h3>denclue</h3><div class="usage"><code>(denclue data sigma m)</code></div><div class="doc"><div class="markdown"><p>DENsity CLUstering algorithm.</p>
<p>Input:</p>
<ul>
  <li>data - sequence of samples</li>
  <li>sigma - gaussian kernel parameter</li>
  <li>m - number of selected samples, much slower than number of all samples</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/smile/api/java/smile/clustering/DENCLUE.html">SMILE doc</a></p></div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Expect 2 clusters, uniform distribution.</p></blockquote><pre><code class="hljs clojure">((juxt :clusters :sizes :representatives)
 (denclue (repeatedly 100 (fn* [] (r/randval (r/drand) (r/drand 5 6))))
          1
          10))
;;=&gt; [2 (47 53) nil]
(map
 (fn [m] (dissoc m :data))
 (regroup
  (denclue (repeatedly 1000
                       (fn* [] (r/randval 0.1 (r/drand) (r/drand 5 6))))
           1
           10)))
;;=&gt; ({:key 0,
;;=&gt;   :outliers? false,
;;=&gt;   :representative 5.492100394867709,
;;=&gt;   :size 921}
;;=&gt;  {:key 1,
;;=&gt;   :outliers? false,
;;=&gt;   :representative 0.5259236825946074,
;;=&gt;   :size 79})</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L195">view source</a></div></div><div class="public anchor" id="var-deterministic-annealing"><h3>deterministic-annealing</h3><div class="usage"><code>(deterministic-annealing data max-clusters)</code><code>(deterministic-annealing data max-clusters alpha)</code></div><div class="doc"><div class="markdown"><p>Deterministic Annealing algorithm.</p>
<p>Input:</p>
<ul>
  <li>data - sequence of samples</li>
  <li>max-clusters - number of clusters</li>
  <li>alpha (optional) - temperature decreasing factor (valued from 0 to 1)</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/smile/api/java/smile/clustering/DeterministicAnnealing.html">SMILE doc</a></p></div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Usage</p></blockquote><pre><code class="hljs clojure">(map (fn [m] (dissoc m :data))
     (-&gt; (repeatedly 1000
                     (fn* []
                       (vector (r/randval (r/grand) (r/grand 5 1.0))
                               (r/randval (r/grand) (r/grand 5 1.0)))))
         (deterministic-annealing 4 0.5)
         (regroup)))
;;=&gt; ({:key 0,
;;=&gt;   :outliers? false,
;;=&gt;   :representative (2.281749774618532 0.0019857698024370986),
;;=&gt;   :size 527}
;;=&gt;  {:key 1,
;;=&gt;   :outliers? false,
;;=&gt;   :representative (2.383149237472281 5.05128980572681),
;;=&gt;   :size 473})</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L162">view source</a></div></div><div class="public anchor" id="var-g-means"><h3>g-means</h3><div class="usage"><code>(g-means data max-clusters)</code></div><div class="doc"><div class="markdown"><p>G-Means algorithm.</p>
<p>Input:</p>
<ul>
  <li>data - sequence of samples</li>
  <li>max-clusters - maximum number of clusters</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/smile/api/java/smile/clustering/GMeans.html">SMILE doc</a></p></div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Expect 2 clusters, uniform distribution.</p></blockquote><pre><code class="hljs clojure">((juxt :clusters :sizes :representatives)
 (g-means (repeatedly 100 (fn* [] (r/randval (r/drand) (r/drand 5 6))))
          4))
;;=&gt; [2 (59 41) ((5.471206102047414) (0.5056384852813499))]</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L140">view source</a></div></div><div class="public anchor" id="var-k-means"><h3>k-means</h3><div class="usage"><code>(k-means data clusters)</code><code>(k-means data clusters max-iter)</code><code>(k-means data clusters max-iter runs)</code></div><div class="doc"><div class="markdown"><p>K-Means++ algorithm.</p>
<p>Input:</p>
<ul>
  <li>data - sequence of samples</li>
  <li>clusters - number of clusters</li>
  <li>max-iter (optional) - maximum number of iterations</li>
  <li>runs (optional) - maximum number of runs</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/smile/api/java/smile/clustering/KMeans.html">SMILE doc</a></p></div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Usage</p></blockquote><pre><code class="hljs clojure">(k-means [1 2 3 -1 -1 2 -1 11 111] 4)
;;=&gt; #fastmath.clustering.ClusteringResult
;;=&gt;  {:clustering (3 3 3 0 0 3 0 2 1),
;;=&gt;   :clusters 4,
;;=&gt;   :data [1 2 3 -1 -1 2 -1 11 111],
;;=&gt;   :info {:distortion 2.0000000000000004},
;;=&gt;   :obj
;;=&gt;   #object[smile.clustering.KMeans 0x225d6b97 "K-Means distortion: 2.00000\nClusters of 9 data points of dimension 1:\n  0\t    3 (33.3%)\n  1\t    1 (11.1%)\n  2\t    1 (11.1%)\n  3\t    4 (44.4%)\n"],
;;=&gt;   :predict #<fn@6e4a177f fastmath.clustering="" tructurize[fn]="">,
;;=&gt;   :representatives ((-1.0) (111.0) (11.0) (2.0)),
;;=&gt;   :sizes (3 1 1 4),
;;=&gt;   :type :k-means}</fn@6e4a177f></code></pre></div><div><blockquote><p>Clusters group into separate maps.</p></blockquote><pre><code class="hljs clojure">(regroup (k-means [1 2 3 -1 -1 2 -1 11 111] 4))
;;=&gt; ({:data (1 2 3 2),
;;=&gt;   :key 3,
;;=&gt;   :outliers? false,
;;=&gt;   :representative (2.0),
;;=&gt;   :size 4}
;;=&gt;  {:data (-1 -1 -1),
;;=&gt;   :key 0,
;;=&gt;   :outliers? false,
;;=&gt;   :representative (-1.0),
;;=&gt;   :size 3}
;;=&gt;  {:data (11), :key 2, :outliers? false, :representative (11.0), :size 1}
;;=&gt;  {:data (111),
;;=&gt;   :key 1,
;;=&gt;   :outliers? false,
;;=&gt;   :representative (111.0),
;;=&gt;   :size 1})</code></pre></div><div><blockquote><p>Use as predictor</p></blockquote><pre><code class="hljs clojure">(let [cl (k-means [1 2 3 -1 -1 2 -1 11 111] 4)]
  [(cl -1) (cl 10) (cl 100) (cl 1) (cl -1000) (cl 1000)])
;;=&gt; [3 2 1 0 3 1]</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L125">view source</a></div></div><div class="public anchor" id="var-mec"><h3>mec</h3><div class="usage"><code>(mec data max-clusters radius)</code><code>(mec data dist max-clusters radius)</code></div><div class="doc"><div class="markdown"><p>Nonparametric Minimum Conditional Entropy Clustering algorithm.</p>
<p>Input:</p>
<ul>
  <li>data - sequence of samples</li>
  <li>dist (optional) - distance method, default <code>:euclidean</code></li>
  <li>max-clusters - maximum number of clusters</li>
  <li>radius - the neighborhood radius</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/smile/api/java/smile/clustering/MEC.html">SMILE doc</a></p></div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>2d vectors</p></blockquote><pre><code class="hljs clojure">(dissoc (mec (repeatedly
              5000
              (fn* []
                (vector
                 (r/randval 0.1 (r/irand -10 10) (r/irand 100 150))
                 (r/randval (r/irand -10 10) (r/irand 100 150)))))
             d/manhattan
             8
             20)
        :data :clustering
        :obj :predict)
;;=&gt; {:clusters 5,
;;=&gt;  :info {:entropy 238.4684462765351},
;;=&gt;  :representatives nil,
;;=&gt;  :sizes (1232 1004 2298 219 247),
;;=&gt;  :type :mec}</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L241">view source</a></div></div><div class="public anchor" id="var-neural-gas"><h3>neural-gas</h3><div class="usage"><code>(neural-gas data clusters)</code><code>(neural-gas data clusters lambda-i lambda-f eps-i eps-f steps)</code></div><div class="doc"><div class="markdown"><p>Neural Gas algorithm.</p>
<p>Input:</p>
<ul>
  <li>data - sequence of samples</li>
  <li>clusters - number of clusters</li>
</ul>
<p>Optional:</p>
<ul>
  <li>lambda-i - intial lambda value (soft learning radius/rate)</li>
  <li>lambda-f - final lambda value</li>
  <li>eps-i - initial epsilon value (learning rate)</li>
  <li>eps-f - final epsilon value</li>
  <li>steps - number of iterations</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/smile/api/java/smile/vq/NeuralGas.html">SMILE doc</a></p></div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Usage</p></blockquote><pre><code class="hljs clojure">(neural-gas [1 2 3 -1 -1 2 -1 11 111] 4)
;;=&gt; #fastmath.clustering.ClusteringResult
;;=&gt;  {:clustering (0 0 0 0 0 0 0 3 1),
;;=&gt;   :clusters 4,
;;=&gt;   :data [1 2 3 -1 -1 2 -1 11 111],
;;=&gt;   :info {:distortion 100.21135606663056},
;;=&gt;   :obj
;;=&gt;   #object[smile.vq.NeuralGas 0x6a41576 "Neural Gas distortion: 100.21136\nClusters of 9 data points of dimension 1:\n  0\t    7 (77.8%)\n  1\t    1 (11.1%)\n  2\t    0 ( 0.0%)\n  3\t    1 (11.1%)\n"],
;;=&gt;   :predict #<fn@53837034 fastmath.clustering="" tructurize[fn]="">,
;;=&gt;   :representatives ((0.6767057694246992)
;;=&gt;                     (102.02680736489556)
;;=&gt;                     (38.047386026088205)
;;=&gt;                     (9.498429886559977)),
;;=&gt;   :sizes (7 1 0 1),
;;=&gt;   :type :neural-gas}</fn@53837034></code></pre></div><div><blockquote><p>Clusters group into separate maps.</p></blockquote><pre><code class="hljs clojure">(regroup (neural-gas [1 2 3 -1 -1 2 -1 11 111] 4))
;;=&gt; ({:data (1 2 3 -1 -1 2 -1),
;;=&gt;   :key 0,
;;=&gt;   :outliers? false,
;;=&gt;   :representative (0.6767057694246992),
;;=&gt;   :size 7}
;;=&gt;  {:data (11),
;;=&gt;   :key 3,
;;=&gt;   :outliers? false,
;;=&gt;   :representative (9.498429886559977),
;;=&gt;   :size 1}
;;=&gt;  {:data (111),
;;=&gt;   :key 1,
;;=&gt;   :outliers? false,
;;=&gt;   :representative (102.02680736489556),
;;=&gt;   :size 1})</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L175">view source</a></div></div><div class="public anchor" id="var-outlier-id"><h3>outlier-id</h3><h4 class="dynamic">const</h4><div class="usage"></div><div><div class="markdown"><code class="hljs clojure">;;=&gt; 2147483647</code></div></div><div class="doc"><div class="markdown"><p>Id of the cluster which contain outliers.</p></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L72">view source</a></div></div><div class="public anchor" id="var-predict"><h3>predict</h3><div class="usage"><code>(predict cluster in)</code></div><div class="doc"><div class="markdown"><p>Predict cluster for given vector</p></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L78">view source</a></div></div><div class="public anchor" id="var-regroup"><h3>regroup</h3><div class="usage"><code>(regroup clustered-data)</code></div><div class="doc"><div class="markdown"><p>Transform clustering result into list of clusters as separate maps.</p>
<p>Every map contain:</p>
<ul>
  <li><code>:key</code> - cluster id</li>
  <li><code>:data</code> - samples which belong to the cluster</li>
  <li><code>:outliers?</code> - does it contain outliers or not</li>
  <li><code>:representative</code> - centroid/medoid or average vector if the former is not available</li>
  <li><code>:size</code> - size of cluster</li>
</ul>
<p>Representative is always a n-dimensional sequence even if input is a list of numbers.</p>
<p>Empty clusters are skipped.</p></div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Result of clustering with regrouping</p></blockquote><pre><code class="hljs clojure">(k-means [1 2 3 -1 -1 2 -1 11 111] 7)
;;=&gt; #fastmath.clustering.ClusteringResult
;;=&gt;  {:clustering (5 3 4 0 0 3 0 2 1),
;;=&gt;   :clusters 7,
;;=&gt;   :data [1 2 3 -1 -1 2 -1 11 111],
;;=&gt;   :info {:distortion 0.0},
;;=&gt;   :obj
;;=&gt;   #object[smile.clustering.KMeans 0x4c5c771f "K-Means distortion: 0.00000\nClusters of 9 data points of dimension 1:\n  0\t    3 (33.3%)\n  1\t    1 (11.1%)\n  2\t    1 (11.1%)\n  3\t    2 (22.2%)\n  4\t    1 (11.1%)\n  5\t    1 (11.1%)\n  6\t    0 ( 0.0%)\n"],
;;=&gt;   :predict #<fn@715cf4ff fastmath.clustering="" tructurize[fn]="">,
;;=&gt;   :representatives ((-1.0) (111.0) (11.0) (2.0) (3.0) (1.0) (##NaN)),
;;=&gt;   :sizes (3 1 1 2 1 1 0),
;;=&gt;   :type :k-means}
(regroup (k-means [1 2 3 -1 -1 2 -1 11 111] 7))
;;=&gt; ({:data (1), :key 5, :outliers? false, :representative (1.0), :size 1}
;;=&gt;  {:data (2 2), :key 3, :outliers? false, :representative (2.0), :size 2}
;;=&gt;  {:data (3), :key 4, :outliers? false, :representative (3.0), :size 1}
;;=&gt;  {:data (-1 -1 -1),
;;=&gt;   :key 2,
;;=&gt;   :outliers? false,
;;=&gt;   :representative (-1.0),
;;=&gt;   :size 3}
;;=&gt;  {:data (11), :key 0, :outliers? false, :representative (11.0), :size 1}
;;=&gt;  {:data (111),
;;=&gt;   :key 1,
;;=&gt;   :outliers? false,
;;=&gt;   :representative (111.0),
;;=&gt;   :size 1})
(count (regroup (k-means [1 2 3 -1 -1 2 -1 11 111] 7)))
;;=&gt; 6</fn@715cf4ff></code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L255">view source</a></div></div><div class="public anchor" id="var-x-means"><h3>x-means</h3><div class="usage"><code>(x-means data max-clusters)</code></div><div class="doc"><div class="markdown"><p>X-Means algorithm.</p>
<p>Input:</p>
<ul>
  <li>data - sequence of samples</li>
  <li>max-clusters - number of clusters</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/smile/api/java/smile/clustering/XMeans.html">SMILE doc</a></p></div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Expect 2 clusters, gaussian distribution.</p></blockquote><pre><code class="hljs clojure">((juxt :clusters :sizes :representatives)
 (x-means (repeatedly 10000
                      (fn* [] (r/randval (r/grand) (r/grand 5 1.0))))
          4))
;;=&gt; [2 (5073 4927) ((-0.018052913493443352) (5.02545863420619))]</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath/blob/master/src/fastmath/clustering.clj#L151">view source</a></div></div></div></body></html>